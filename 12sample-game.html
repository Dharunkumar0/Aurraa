<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Adventure - Electric Charges and Fields</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 25px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 1200px;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .game-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .game-header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        .game-title {
            font-family: 'Orbitron', monospace;
            font-size: 32px;
            font-weight: 900;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            position: relative;
            z-index: 1;
        }
        
        .game-subtitle {
            font-size: 18px;
            opacity: 0.9;
            position: relative;
            z-index: 1;
        }
        
        .language-selector {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 2;
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            padding: 5px;
        }
        
        .globe-icon {
            margin-right: 8px;
            font-size: 18px;
        }
        
        .language-select {
            background: transparent;
            border: none;
            color: white;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            outline: none;
            padding: 5px 10px;
            border-radius: 20px;
            transition: background 0.3s;
        }
        
        .language-select:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .language-select option {
            background: #667eea;
            color: white;
        }
        
        .game-content {
            padding: 30px;
        }
        
        .level-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .level-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            padding: 20px;
            min-width: 200px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            border: 3px solid transparent;
            position: relative;
            overflow: hidden;
        }
        
        .level-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s;
        }
        
        .level-card:hover::before {
            left: 100%;
        }
        
        .level-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .level-card.active {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .level-card.completed {
            border-color: #4caf50;
        }
        
        .level-card.completed::after {
            content: 'âœ“';
            position: absolute;
            top: 10px;
            right: 10px;
            background: #4caf50;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        
        .level-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        .level-name {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .level-desc {
            font-size: 14px;
            opacity: 0.8;
        }
        
        .puzzle-container {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .puzzle-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }
        
        .simulation-area {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        /* Field Visualizer Styles */
        .field-visualizer-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .field-canvas {
            height: 500px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            border: 2px solid #e0e0e0;
        }
        
        .field-charge {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: 700;
            color: white;
            cursor: move;
            transition: box-shadow 0.3s ease;
            z-index: 10;
            user-select: none;
        }
        
        .field-charge.positive {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ee5a24);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }
        
        .field-charge.negative {
            background: radial-gradient(circle at 30% 30%, #4ecdc4, #44a3aa);
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }
        
        .field-charge:hover {
            transform: scale(1.1);
        }
        
        .field-charge.dragging {
            transform: scale(1.2);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.3);
        }
        
        .field-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.7), rgba(118, 75, 162, 0.7));
            transform-origin: left center;
            z-index: 1;
        }
        
        .field-arrow {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid rgba(102, 126, 234, 0.7);
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            z-index: 2;
        }
        
        .force-vector {
            position: absolute;
            height: 4px;
            transform-origin: left center;
            z-index: 5;
        }
        
        .force-vector::after {
            content: '';
            position: absolute;
            right: -10px;
            top: -6px;
            width: 0;
            height: 0;
            border-left: 15px solid;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
        }
        
        .force-vector.attraction {
            background: linear-gradient(90deg, #4ecdc4, #44a3aa);
        }
        
        .force-vector.attraction::after {
            border-left-color: #44a3aa;
        }
        
        .force-vector.repulsion {
            background: linear-gradient(90deg, #ff6b6b, #ee5a24);
        }
        
        .force-vector.repulsion::after {
            border-left-color: #ee5a24;
        }
        
        .field-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .field-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 12px 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .field-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .field-btn.active {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a3aa 100%);
        }
        
        .field-info {
            background: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 3px 15px rgba(0, 0, 0, 0.08);
            text-align: center;
        }
        
        .field-info-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .field-info-value {
            font-size: 18px;
            font-weight: 700;
            color: #667eea;
        }
        
        /* Coulomb's Lab Enhanced Styles */
        .coulombs-lab-container {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        
        .force-visualization {
            height: 400px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            border: 2px solid #e0e0e0;
        }
        
        .charge-ball {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            font-weight: 700;
            color: white;
            cursor: move;
            transition: box-shadow 0.3s ease;
            z-index: 10;
            user-select: none;
        }
        
        .charge-ball.positive {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ee5a24);
            box-shadow: 0 0 30px rgba(255, 107, 107, 0.6);
        }
        
        .charge-ball.negative {
            background: radial-gradient(circle at 30% 30%, #4ecdc4, #44a3aa);
            box-shadow: 0 0 30px rgba(78, 205, 196, 0.6);
        }
        
        .charge-ball:hover {
            transform: scale(1.05);
        }
        
        .charge-ball.dragging {
            transform: scale(1.1);
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.3);
        }
        
        .force-vector {
            position: absolute;
            height: 6px;
            background: linear-gradient(90deg, #feca57, #ff9ff3);
            transform-origin: left center;
            transition: all 0.3s ease;
            z-index: 5;
        }
        
        .force-vector::after {
            content: '';
            position: absolute;
            right: -15px;
            top: -10px;
            width: 0;
            height: 0;
            border-left: 25px solid #ff9ff3;
            border-top: 12px solid transparent;
            border-bottom: 12px solid transparent;
        }
        
        .force-vector.attraction {
            background: linear-gradient(90deg, #4ecdc4, #44a3aa);
        }
        
        .force-vector.attraction::after {
            border-left-color: #44a3aa;
        }
        
        .distance-line {
            position: absolute;
            height: 2px;
            background: #ddd;
            border-top: 2px dashed #999;
            z-index: 1;
        }
        
        .distance-label {
            position: absolute;
            background: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 15;
        }
        
        .controls-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
        }
        
        .control-group {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 3px 15px rgba(0, 0, 0, 0.08);
        }
        
        .control-label {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: white;
        }
        
        .control-icon.positive {
            background: #ff6b6b;
        }
        
        .control-icon.negative {
            background: #4ecdc4;
        }
        
        .control-icon.distance {
            background: #667eea;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }
        
        .slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #e0e0e0;
            border-radius: 5px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
        }
        
        .slider-value {
            min-width: 80px;
            padding: 8px 12px;
            background: #f0f3ff;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-weight: 600;
            color: #667eea;
            text-align: center;
            font-size: 14px;
        }
        
        .result-display {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }
        
        .result-label {
            font-size: 16px;
            opacity: 0.9;
            margin-bottom: 10px;
        }
        
        .result-value {
            font-size: 36px;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .result-unit {
            font-size: 18px;
            opacity: 0.8;
            margin-left: 5px;
        }
        
        .success-message {
            background: linear-gradient(135deg, #4caf50, #45a049);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin-top: 20px;
            font-size: 18px;
            font-weight: 500;
        }
        
        .controls-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        .control-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 12px 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .control-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .control-btn.next-btn {
            background: linear-gradient(135deg, #4caf50, #45a049);
        }
        
        .control-btn.next-btn:hover {
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }
        
        /* Potential Maze Styles */
        .maze-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .maze-visualization {
            height: 500px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            border: 2px solid #e0e0e0;
        }
        
        .maze-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(10, 1fr);
            gap: 1px;
        }
        
        .maze-cell {
            background: white;
            position: relative;
        }
        
        .maze-cell.wall {
            background: #333;
        }
        
        .maze-cell.start {
            background: #4ecdc4;
        }
        
        .maze-cell.end {
            background: #ff6b6b;
        }
        
        .player {
            position: absolute;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle at 30% 30%, #feca57, #ff9ff3);
            border-radius: 50%;
            transition: all 0.2s ease;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 700;
            color: white;
        }
        
        .maze-charge {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: 700;
            color: white;
            cursor: move;
            transition: box-shadow 0.3s ease;
            z-index: 15;
            user-select: none;
        }
        
        .maze-charge.positive {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ee5a24);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }
        
        .maze-charge.negative {
            background: radial-gradient(circle at 30% 30%, #4ecdc4, #44a3aa);
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }
        
        .maze-charge:hover {
            transform: scale(1.1);
        }
        
        .maze-charge.dragging {
            transform: scale(1.2);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.3);
        }
        
        .potential-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            z-index: 20;
        }
        
        .potential-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .potential-value {
            font-size: 24px;
            font-weight: 700;
            color: #667eea;
        }
        
        /* Gauss Challenge Styles */
        .gauss-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .gauss-visualization {
            height: 500px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            border: 2px solid #e0e0e0;
        }
        
        .gauss-charge {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: 700;
            color: white;
            z-index: 5;
            user-select: none;
        }
        
        .gauss-charge.positive {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ee5a24);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }
        
        .gauss-charge.negative {
            background: radial-gradient(circle at 30% 30%, #4ecdc4, #44a3aa);
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }
        
        .gaussian-surface {
            position: absolute;
            border: 3px dashed #667eea;
            border-radius: 50%;
            pointer-events: none;
            background: rgba(102, 126, 234, 0.1);
            cursor: move;
            z-index: 10;
        }
        
        .gaussian-surface.dragging {
            border-color: #ff9ff3;
            background: rgba(255, 159, 243, 0.1);
        }
        
        .flux-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            z-index: 20;
        }
        
        .flux-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .flux-value {
            font-size: 24px;
            font-weight: 700;
            color: #667eea;
        }
        
        .enclosed-value {
            font-size: 20px;
            font-weight: 600;
            color: #764ba2;
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            .game-header {
                padding: 20px;
            }
            
            .game-title {
                font-size: 24px;
            }
            
            .language-selector {
                position: static;
                margin-top: 15px;
                text-align: center;
                justify-content: center;
            }
            
            .game-content {
                padding: 20px;
            }
            
            .level-card {
                min-width: 150px;
            }
            
            .controls-panel {
                grid-template-columns: 1fr;
            }
            
            .charge-ball {
                width: 60px;
                height: 60px;
                font-size: 28px;
            }
            
            .force-visualization {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Translations for different languages
        const translations = {
            eng: {
                title: "Physics Adventure",
                subtitle: "Electric Charges and Fields - Grade 12",
                levels: [
                    { name: "Field Visualizer", desc: "Create electric fields", icon: "âš¡" },
                    { name: "Coulomb's Lab", desc: "Experiment with forces", icon: "ðŸ”¬" },
                    { name: "Gauss Challenge", desc: "Master flux calculation", icon: "ðŸŒ€" },
                    { name: "Potential Maze", desc: "Navigate by potential", icon: "ðŸŽ¯" }
                ],
                fieldVisualizer: {
                    title: "Electric Field Visualizer",
                    instruction: "Place charges to create electric fields. Try different configurations!",
                    positive: "Add Positive",
                    negative: "Add Negative",
                    clear: "Clear All",
                    charges: "Charges",
                    success: "Great! You've created an electric field!",
                    reset: "Reset Field"
                },
                coulombsLab: {
                    title: "Coulomb's Law Laboratory",
                    instruction: "Drag the charges to see how the force changes. Experiment with different configurations!",
                    charge1: "Charge 1",
                    charge2: "Charge 2",
                    distance: "Distance",
                    force: "Force",
                    success: "Excellent! You've experimented with Coulomb's Law!",
                    reset: "Reset Experiment"
                },
                potentialMaze: {
                    title: "Electric Potential Maze",
                    instruction: "Navigate the maze and move charges to explore electric potential!",
                    potential: "Current Potential",
                    success: "Congratulations! You've explored the potential maze!",
                    reset: "Reset Maze"
                },
                gaussChallenge: {
                    title: "Gauss's Law Challenge",
                    instruction: "Move the Gaussian surface to explore electric flux!",
                    flux: "Electric Flux",
                    enclosed: "Enclosed Charge",
                    success: "Excellent! You've explored Gauss's Law!",
                    reset: "Reset Challenge"
                },
                controls: {
                    play: "Play",
                    pause: "Pause",
                    replay: "Replay",
                    next: "Next"
                }
            },
            tam: {
                title: "à®‡à®¯à®±à¯à®ªà®¿à®¯à®²à¯ à®šà®¾à®•à®šà®®à¯",
                subtitle: "à®®à®¿à®©à¯ à®šà¯à®®à¯ˆà®•à®³à¯ à®®à®±à¯à®±à¯à®®à¯ à®®à®¿à®©à¯ à®ªà¯à®²à®™à¯à®•à®³à¯ - 12 à®†à®®à¯ à®µà®•à¯à®ªà¯à®ªà¯",
                levels: [
                    { name: "à®ªà¯à®²à®•à¯ à®•à®¾à®Ÿà¯à®šà®¿à®¯à®•à®®à¯", desc: "à®®à®¿à®©à¯ à®ªà¯à®²à®™à¯à®•à®³à¯ˆ à®‰à®°à¯à®µà®¾à®•à¯à®•à¯à®™à¯à®•à®³à¯", icon: "âš¡" },
                    { name: "à®•à¯‚à®²à¯‹à®®à¯à®ªà®¿à®©à¯ à®†à®¯à¯à®µà®•à®®à¯", desc: "à®µà®¿à®šà¯ˆà®•à®³à¯à®Ÿà®©à¯ à®ªà®°à®¿à®šà¯‹à®¤à®¿à®•à¯à®•à®µà¯à®®à¯", icon: "ðŸ”¬" },
                    { name: "à®•à®¾à®¸à¯ à®šà®µà®¾à®²à¯", desc: "à®ªà®¾à®¯à¯à®µà¯ à®•à®£à®•à¯à®•à¯€à®Ÿà¯à®Ÿà¯ˆ à®®à¯à®Ÿà®¿à®•à¯à®•à®µà¯à®®à¯", icon: "ðŸŒ€" },
                    { name: "à®¤à®¿à®±à®©à¯ à®šà®¿à®•à¯à®•à®²à®¾à®© à®ªà®¾à®¤à¯ˆ", desc: "à®šà®® à®¤à®¿à®±à®©à¯ à®•à¯‹à®Ÿà¯à®•à®³à¯ˆà®ªà¯ à®ªà®¿à®©à¯à®ªà®±à¯à®±à®µà¯à®®à¯", icon: "ðŸŽ¯" }
                ],
                fieldVisualizer: {
                    title: "à®®à®¿à®©à¯ à®ªà¯à®²à®•à¯ à®•à®¾à®Ÿà¯à®šà®¿à®¯à®•à®®à¯",
                    instruction: "à®®à®¿à®©à¯ à®ªà¯à®²à®™à¯à®•à®³à¯ˆ à®‰à®°à¯à®µà®¾à®•à¯à®• à®šà¯à®®à¯ˆà®•à®³à¯ˆ à®µà¯ˆà®•à¯à®•à®µà¯à®®à¯. à®µà¯†à®µà¯à®µà¯‡à®±à¯ à®•à®Ÿà¯à®Ÿà®®à¯ˆà®ªà¯à®ªà¯à®•à®³à¯ˆ à®®à¯à®¯à®±à¯à®šà®¿à®•à¯à®•à®µà¯à®®à¯!",
                    positive: "à®¨à¯‡à®°à¯à®®à®±à¯ˆà®¯à¯ˆà®šà¯ à®šà¯‡à®°à¯",
                    negative: "à®Žà®¤à®¿à®°à¯à®®à®±à¯ˆà®¯à¯ˆà®šà¯ à®šà¯‡à®°à¯",
                    clear: "à®…à®©à¯ˆà®¤à¯à®¤à¯ˆà®¯à¯à®®à¯ à®…à®´à®¿",
                    charges: "à®šà¯à®®à¯ˆà®•à®³à¯",
                    success: "à®…à®±à¯à®ªà¯à®¤à®®à¯! à®¨à¯€à®™à¯à®•à®³à¯ à®’à®°à¯ à®®à®¿à®©à¯ à®ªà¯à®²à®¤à¯à®¤à¯ˆ à®‰à®°à¯à®µà®¾à®•à¯à®•à®¿à®¯à¯à®³à¯à®³à¯€à®°à¯à®•à®³à¯!",
                    reset: "à®ªà¯à®²à®¤à¯à®¤à¯ˆ à®®à¯€à®Ÿà¯à®Ÿà®®à¯ˆ"
                },
                coulombsLab: {
                    title: "à®•à¯‚à®²à¯‹à®®à¯à®ªà®¿à®©à¯ à®šà®Ÿà¯à®Ÿà®®à¯ à®†à®¯à¯à®µà®•à®®à¯",
                    instruction: "à®µà®¿à®šà¯ˆ à®Žà®µà¯à®µà®¾à®±à¯ à®®à®¾à®±à¯à®•à®¿à®±à®¤à¯ à®Žà®©à¯à®ªà®¤à¯ˆà®•à¯ à®•à®¾à®£ à®šà¯à®®à¯ˆà®•à®³à¯ˆ à®‡à®´à¯à®¤à¯à®¤à¯à®ªà¯ à®ªà¯‹à®Ÿà¯à®™à¯à®•à®³à¯. à®µà¯†à®µà¯à®µà¯‡à®±à¯ à®•à®Ÿà¯à®Ÿà®®à¯ˆà®ªà¯à®ªà¯à®•à®³à¯ˆ à®®à¯à®¯à®±à¯à®šà®¿à®•à¯à®•à®µà¯à®®à¯!",
                    charge1: "à®šà¯à®®à¯ˆ 1",
                    charge2: "à®šà¯à®®à¯ˆ 2",
                    distance: "à®¤à¯‚à®°à®®à¯",
                    force: "à®µà®¿à®šà¯ˆ",
                    success: "à®šà®¿à®±à®ªà¯à®ªà¯! à®¨à¯€à®™à¯à®•à®³à¯ à®•à¯‚à®²à¯‹à®®à¯à®ªà®¿à®©à¯ à®šà®Ÿà¯à®Ÿà®¤à¯à®¤à¯ˆ à®šà®¿à®±à®ªà¯à®ªà®¾à®• à®•à®±à¯à®±à¯à®•à¯à®•à¯Šà®£à¯à®Ÿà¯€à®°à¯à®•à®³à¯!",
                    reset: "à®ªà®°à®¿à®šà¯‹à®¤à®©à¯ˆà®¯à¯ˆ à®®à¯€à®Ÿà¯à®Ÿà®®à¯ˆ"
                },
                potentialMaze: {
                    title: "à®®à®¿à®©à¯ à®¤à®¿à®±à®©à¯ à®šà®¿à®•à¯à®•à®²à®¾à®© à®ªà®¾à®¤à¯ˆ",
                    instruction: "à®šà®¿à®•à¯à®•à®²à®¾à®© à®ªà®¾à®¤à¯ˆà®¯à¯ˆà®¤à¯ à®¤à®¾à®£à¯à®Ÿà®¿ à®šà¯à®®à¯ˆà®•à®³à¯ˆ à®¨à®•à®°à¯à®¤à¯à®¤à®¿ à®®à®¿à®©à¯ à®¤à®¿à®±à®©à¯ˆ à®†à®°à®¾à®¯à¯à®™à¯à®•à®³à¯!",
                    potential: "à®¤à®±à¯à®ªà¯‹à®¤à¯ˆà®¯ à®¤à®¿à®±à®©à¯",
                    success: "à®µà®¾à®´à¯à®¤à¯à®¤à¯à®•à¯à®•à®³à¯! à®¨à¯€à®™à¯à®•à®³à¯ à®šà®¿à®•à¯à®•à®²à®¾à®© à®ªà®¾à®¤à¯ˆà®¯à¯ˆ à®†à®°à®¾à®¯à¯à®¨à¯à®¤à¯à®³à¯à®³à¯€à®°à¯à®•à®³à¯!",
                    reset: "à®šà®¿à®•à¯à®•à®²à®¾à®© à®ªà®¾à®¤à¯ˆà®¯à¯ˆ à®®à¯€à®Ÿà¯à®Ÿà®®à¯ˆ"
                },
                gaussChallenge: {
                    title: "à®•à®¾à®¸à¯ à®šà®Ÿà¯à®Ÿà®®à¯ à®šà®µà®¾à®²à¯",
                    instruction: "à®•à®¾à®¸à®¿à®¯à®©à¯ à®®à¯‡à®±à¯à®ªà®°à®ªà¯à®ªà¯ˆ à®¨à®•à®°à¯à®¤à¯à®¤à®¿ à®®à®¿à®©à¯ à®ªà®¾à®¯à¯à®µà¯ˆ à®†à®°à®¾à®¯à¯à®™à¯à®•à®³à¯!",
                    flux: "à®®à®¿à®©à¯ à®ªà®¾à®¯à¯à®µà¯",
                    enclosed: "à®®à¯‚à®Ÿà®ªà¯à®ªà®Ÿà¯à®Ÿ à®šà¯à®®à¯ˆ",
                    success: "à®…à®°à¯à®®à¯ˆ! à®¨à¯€à®™à¯à®•à®³à¯ à®•à®¾à®¸à¯ à®šà®Ÿà¯à®Ÿà®¤à¯à®¤à¯ˆ à®šà®°à®¿à®¯à®¾à®•à®ªà¯ à®ªà®¯à®©à¯à®ªà®Ÿà¯à®¤à¯à®¤à®¿à®¯à¯à®³à¯à®³à¯€à®°à¯à®•à®³à¯!",
                    reset: "à®šà®µà®¾à®²à¯ˆ à®®à¯€à®Ÿà¯à®Ÿà®®à¯ˆ"
                },
                controls: {
                    play: "à®µà®¿à®³à¯ˆà®¯à®¾à®Ÿà¯",
                    pause: "à®‡à®Ÿà¯ˆà®¨à®¿à®±à¯à®¤à¯à®¤à¯",
                    replay: "à®®à¯€à®£à¯à®Ÿà¯à®®à¯ à®µà®¿à®³à¯ˆà®¯à®¾à®Ÿà¯",
                    next: "à®…à®Ÿà¯à®¤à¯à®¤à®¤à¯"
                }
            },
            tel: {
                title: "à°­à±Œà°¤à°¿à°• à°¶à°¾à°¸à±à°¤à±à°°à°‚ à°¸à°¾à°¹à°¸ à°¯à°¾à°¤à±à°°",
                subtitle: "à°Žà°²à°•à±à°Ÿà±à°°à°¿à°•à± à°›à°¾à°°à±à°œà±€à°²à± à°®à°°à°¿à°¯à± à°«à±€à°²à±à°¡à±à°¸à± - 12à°µ à°¤à°°à°—à°¤à°¿",
                levels: [
                    { name: "à°«à±€à°²à±à°¡à± à°µà°¿à°œà±à°µà°²à±ˆà°œà°°à±", desc: "à°Žà°²à°•à±à°Ÿà±à°°à°¿à°•à± à°«à±€à°²à±à°¡à±à°¸à± à°¸à±ƒà°·à±à°Ÿà°¿à°‚à°šà°‚à°¡à°¿", icon: "âš¡" },
                    { name: "à°•à±Œà°²à°®à±à°¬à± à°²à±à°¯à°¾à°¬à±", desc: "à°«à±‹à°°à±à°¸à±†à°¸à±â€Œà°¤à±‹ à°ªà±à°°à°¯à±‹à°—à°‚ à°šà±‡à°¯à°‚à°¡à°¿", icon: "ðŸ”¬" },
                    { name: "à°—à°¾à°¸à± à°›à°¾à°²à±†à°‚à°œà±", desc: "à°«à±à°²à°•à±à°¸à± à°²à±†à°•à±à°•à°¿à°‚à°ªà± à°®à°¾à°¸à±à°Ÿà°°à± à°šà±‡à°¯à°‚à°¡à°¿", icon: "ðŸŒ€" },
                    { name: "à°ªà±Šà°Ÿà±†à°¨à±à°·à°¿à°¯à°²à± à°®à±‡à°œà±", desc: "à°ªà±Šà°Ÿà±†à°¨à±à°·à°¿à°¯à°²à± à°¦à±à°µà°¾à°°à°¾ à°¨à°¾à°µà°¿à°—à±‡à°Ÿà± à°šà±‡à°¯à°‚à°¡à°¿", icon: "ðŸŽ¯" }
                ],
                fieldVisualizer: {
                    title: "à°Žà°²à°•à±à°Ÿà±à°°à°¿à°•à± à°«à±€à°²à±à°¡à± à°µà°¿à°œà±à°µà°²à±ˆà°œà°°à±",
                    instruction: "à°Žà°²à°•à±à°Ÿà±à°°à°¿à°•à± à°«à±€à°²à±à°¡à±à°¸à± à°¸à±ƒà°·à±à°Ÿà°¿à°‚à°šà°¡à°¾à°¨à°¿à°•à°¿ à°›à°¾à°°à±à°œà±€à°²à°¨à± à°‰à°‚à°šà°‚à°¡à°¿. à°µà°¿à°µà°¿à°§ à°†à°•à±ƒà°¤à±€à°•à°°à°£à°²à°¨à± à°ªà±à°°à°¯à°¤à±à°¨à°¿à°‚à°šà°‚à°¡à°¿!",
                    positive: "à°ªà°¾à°œà°¿à°Ÿà°¿à°µà± à°œà±‹à°¡à°¿à°‚à°šà±",
                    negative: "à°¨à±†à°—à°¿à°Ÿà°¿à°µà± à°œà±‹à°¡à°¿à°‚à°šà±",
                    clear: "à°…à°¨à±à°¨à°¿à°‚à°Ÿà°¿à°¨à±€ à°¤à±€à°¸à°¿à°µà±‡à°¯à°¿",
                    charges: "à°›à°¾à°°à±à°œà±€à°²à±",
                    success: "à°—à±Šà°ªà±à°ª! à°®à±€à°°à± à°Žà°²à°•à±à°Ÿà±à°°à°¿à°•à± à°«à±€à°²à±à°¡à±â€Œà°¨à± à°¸à±ƒà°·à±à°Ÿà°¿à°‚à°šà°¾à°°à±!",
                    reset: "à°«à±€à°²à±à°¡à±â€Œà°¨à± à°°à±€à°¸à±†à°Ÿà± à°šà±‡à°¯à°‚à°¡à°¿"
                },
                coulombsLab: {
                    title: "à°•à±Œà°²à°®à±à°¬à± à°²à°¾ à°²à±à°¯à°¾à°¬à±Šà°°à±‡à°Ÿà°°à±€",
                    instruction: "à°«à±‹à°°à±à°¸à± à°Žà°²à°¾ à°®à°¾à°°à±à°¤à±à°‚à°¦à±‹ à°šà±‚à°¡à°Ÿà°¾à°¨à°¿à°•à°¿ à°›à°¾à°°à±à°œà±€à°²à°¨à± à°²à°¾à°—à°¿ à°ªà±†à°Ÿà±à°Ÿà°‚à°¡à°¿. à°µà°¿à°µà°¿à°§ à°†à°•à±ƒà°¤à±€à°•à°°à°£à°²à°¨à± à°ªà±à°°à°¯à°¤à±à°¨à°¿à°‚à°šà°‚à°¡à°¿!",
                    charge1: "à°›à°¾à°°à±à°œà± 1",
                    charge2: "à°›à°¾à°°à±à°œà± 2",
                    distance: "à°¦à±‚à°°à°‚",
                    force: "à°«à±‹à°°à±à°¸à±",
                    success: "à°…à°¦à±à°­à±à°¤à°‚! à°®à±€à°°à± à°•à±Œà°²à°®à±à°¬à± à°²à°¾à°¨à± à°®à°¾à°¸à±à°Ÿà°°à± à°šà±‡à°¶à°¾à°°à±!",
                    reset: "à°ªà±à°°à°¯à±‹à°—à°¾à°¨à±à°¨à°¿ à°°à±€à°¸à±†à°Ÿà± à°šà±‡à°¯à°‚à°¡à°¿"
                },
                potentialMaze: {
                    title: "à°Žà°²à°•à±à°Ÿà±à°°à°¿à°•à± à°ªà±Šà°Ÿà±†à°¨à±à°·à°¿à°¯à°²à± à°®à±‡à°œà±",
                    instruction: "à°®à±‡à°œà±â€Œà°¨à± à°¨à°¾à°µà°¿à°—à±‡à°Ÿà± à°šà±‡à°¯à°‚à°¡à°¿ à°®à°°à°¿à°¯à± à°›à°¾à°°à±à°œà±€à°²à°¨à± à°¤à°°à°²à°¿à°‚à°šà°¿ à°Žà°²à°•à±à°Ÿà±à°°à°¿à°•à± à°ªà±Šà°Ÿà±†à°¨à±à°·à°¿à°¯à°²à±â€Œà°¨à± à°…à°¨à±à°µà±‡à°·à°¿à°‚à°šà°‚à°¡à°¿!",
                    potential: "à°ªà±à°°à°¸à±à°¤à±à°¤ à°ªà±Šà°Ÿà±†à°¨à±à°·à°¿à°¯à°²à±",
                    success: "à°…à°­à°¿à°¨à°‚à°¦à°¨à°²à±! à°®à±€à°°à± à°®à±‡à°œà±â€Œà°¨à± à°…à°¨à±à°µà±‡à°·à°¿à°‚à°šà°¾à°°à±!",
                    reset: "à°®à±‡à°œà±â€Œà°¨à± à°°à±€à°¸à±†à°Ÿà± à°šà±‡à°¯à°‚à°¡à°¿"
                },
                gaussChallenge: {
                    title: "à°—à°¾à°¸à± à°²à°¾ à°›à°¾à°²à±†à°‚à°œà±",
                    instruction: "à°—à°¾à°¸à°¿à°¯à°¨à± à°‰à°ªà°°à°¿à°¤à°²à°¾à°¨à±à°¨à°¿ à°•à°¦à°¿à°ªà°¿à°‚à°šà°¿ à°Žà°²à°•à±à°Ÿà±à°°à°¿à°•à± à°«à±à°²à°•à±à°¸à±â€Œà°¨à± à°…à°¨à±à°µà±‡à°·à°¿à°‚à°šà°‚à°¡à°¿!",
                    flux: "à°Žà°²à°•à±à°Ÿà±à°°à°¿à°•à± à°«à±à°²à°•à±à°¸à±",
                    enclosed: "à°®à±‚à°¸à°¿à°¨ à°›à°¾à°°à±à°œà±",
                    success: "à°—à±Šà°ªà±à°ª! à°®à±€à°°à± à°—à°¾à°¸à± à°²à°¾à°¨à± à°¸à°°à±ˆà°¨à°‚à°—à°¾ à°µà°°à±à°¤à°¿à°‚à°šà°¾à°°à±!",
                    reset: "à°›à°¾à°²à±†à°‚à°œà±â€Œà°¨à± à°°à±€à°¸à±†à°Ÿà± à°šà±‡à°¯à°‚à°¡à°¿"
                },
                controls: {
                    play: "à°†à°¡à°‚à°¡à°¿",
                    pause: "à°µà°¿à°°à°¾à°®à°‚",
                    replay: "à°®à°³à±à°³à±€ à°†à°¡à°‚à°¡à°¿",
                    next: "à°¤à°¦à±à°ªà°°à°¿"
                }
            },
            hin: {
                title: "à¤­à¥Œà¤¤à¤¿à¤•à¥€ à¤¸à¤¾à¤¹à¤¸à¤¿à¤• à¤¯à¤¾à¤¤à¥à¤°à¤¾",
                subtitle: "à¤µà¤¿à¤¦à¥à¤¯à¥à¤¤ à¤†à¤µà¥‡à¤¶ à¤”à¤° à¤•à¥à¤·à¥‡à¤¤à¥à¤° - 12à¤µà¥€à¤‚ à¤•à¤•à¥à¤·à¤¾",
                levels: [
                    { name: "à¤•à¥à¤·à¥‡à¤¤à¥à¤° à¤¦à¥ƒà¤¶à¥à¤¯à¤•", desc: "à¤µà¤¿à¤¦à¥à¤¯à¥à¤¤ à¤•à¥à¤·à¥‡à¤¤à¥à¤° à¤¬à¤¨à¤¾à¤à¤‚", icon: "âš¡" },
                    { name: "à¤•à¥‚à¤²à¥‰à¤®à¥à¤¬ à¤ªà¥à¤°à¤¯à¥‹à¤—à¤¶à¤¾à¤²à¤¾", desc: "à¤¬à¤²à¥‹à¤‚ à¤•à¥‡ à¤¸à¤¾à¤¥ à¤ªà¥à¤°à¤¯à¥‹à¤— à¤•à¤°à¥‡à¤‚", icon: "ðŸ”¬" },
                    { name: "à¤—à¥‰à¤¸ à¤šà¥à¤¨à¥Œà¤¤à¥€", desc: "à¤ªà¥à¤°à¤µà¤¾à¤¹ à¤—à¤£à¤¨à¤¾ à¤®à¥‡à¤‚ à¤®à¤¹à¤¾à¤°à¤¤ à¤¹à¥‹à¤‚", icon: "ðŸŒ€" },
                    { name: "à¤µà¤¿à¤­à¤µ à¤®à¤¾à¤°à¥à¤—", desc: "à¤µà¤¿à¤­à¤µ à¤°à¥‡à¤–à¤¾à¤“à¤‚ à¤¸à¥‡ à¤¨à¥‡à¤µà¤¿à¤—à¥‡à¤Ÿ à¤•à¤°à¥‡à¤‚", icon: "ðŸŽ¯" }
                ],
                fieldVisualizer: {
                    title: "à¤µà¤¿à¤¦à¥à¤¯à¥à¤¤ à¤•à¥à¤·à¥‡à¤¤à¥à¤° à¤¦à¥ƒà¤¶à¥à¤¯à¤•",
                    instruction: "à¤µà¤¿à¤¦à¥à¤¯à¥à¤¤ à¤•à¥à¤·à¥‡à¤¤à¥à¤° à¤¬à¤¨à¤¾à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤†à¤µà¥‡à¤¶ à¤°à¤–à¥‡à¤‚à¥¤ à¤µà¤¿à¤­à¤¿à¤¨à¥à¤¨ à¤µà¤¿à¤¨à¥à¤¯à¤¾à¤¸ à¤†à¤œà¤¼à¤®à¤¾à¤à¤‚!",
                    positive: "à¤§à¤¨à¤¾à¤¤à¥à¤®à¤• à¤œà¥‹à¤¡à¤¼à¥‡à¤‚",
                    negative: "à¤‹à¤£à¤¾à¤¤à¥à¤®à¤• à¤œà¥‹à¤¡à¤¼à¥‡à¤‚",
                    clear: "à¤¸à¤­à¥€ à¤¸à¤¾à¤«à¤¼ à¤•à¤°à¥‡à¤‚",
                    charges: "à¤†à¤µà¥‡à¤¶",
                    success: "à¤¬à¤¢à¤¼à¤¿à¤¯à¤¾! à¤†à¤ªà¤¨à¥‡ à¤à¤• à¤µà¤¿à¤¦à¥à¤¯à¥à¤¤ à¤•à¥à¤·à¥‡à¤¤à¥à¤° à¤¬à¤¨à¤¾à¤¯à¤¾ à¤¹à¥ˆ!",
                    reset: "à¤•à¥à¤·à¥‡à¤¤à¥à¤° à¤°à¥€à¤¸à¥‡à¤Ÿ à¤•à¤°à¥‡à¤‚"
                },
                coulombsLab: {
                    title: "à¤•à¥‚à¤²à¥‰à¤®à¥à¤¬ à¤•à¤¾ à¤¨à¤¿à¤¯à¤® à¤ªà¥à¤°à¤¯à¥‹à¤—à¤¶à¤¾à¤²à¤¾",
                    instruction: "à¤¬à¤² à¤•à¥ˆà¤¸à¥‡ à¤¬à¤¦à¤²à¤¤à¤¾ à¤¹à¥ˆ à¤¦à¥‡à¤–à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤†à¤µà¥‡à¤¶ à¤–à¥€à¤‚à¤šà¥‡à¤‚à¥¤ à¤µà¤¿à¤­à¤¿à¤¨à¥à¤¨ à¤µà¤¿à¤¨à¥à¤¯à¤¾à¤¸ à¤†à¤œà¤¼à¤®à¤¾à¤à¤‚!",
                    charge1: "à¤†à¤µà¥‡à¤¶ 1",
                    charge2: "à¤†à¤µà¥‡à¤¶ 2",
                    distance: "à¤¦à¥‚à¤°à¥€",
                    force: "à¤¬à¤²",
                    success: "à¤¬à¤¢à¤¼à¤¿à¤¯à¤¾! à¤†à¤ªà¤¨à¥‡ à¤•à¥‚à¤²à¥‰à¤®à¥à¤¬ à¤•à¤¾ à¤¨à¤¿à¤¯à¤® à¤¸à¥€à¤– à¤²à¤¿à¤¯à¤¾!",
                    reset: "à¤ªà¥à¤°à¤¯à¥‹à¤— à¤°à¥€à¤¸à¥‡à¤Ÿ à¤•à¤°à¥‡à¤‚"
                },
                potentialMaze: {
                    title: "à¤µà¤¿à¤¦à¥à¤¯à¥à¤¤ à¤µà¤¿à¤­à¤µ à¤®à¤¾à¤°à¥à¤—",
                    instruction: "à¤®à¤¾à¤°à¥à¤— à¤¨à¥‡à¤µà¤¿à¤—à¥‡à¤Ÿ à¤•à¤°à¥‡à¤‚ à¤”à¤° à¤†à¤µà¥‡à¤¶ à¤–à¥€à¤‚à¤šà¤•à¤° à¤µà¤¿à¤¦à¥à¤¯à¥à¤¤ à¤µà¤¿à¤­à¤µ à¤•à¤¾ à¤…à¤¨à¥à¤µà¥‡à¤·à¤£ à¤•à¤°à¥‡à¤‚!",
                    potential: "à¤µà¤°à¥à¤¤à¤®à¤¾à¤¨ à¤µà¤¿à¤­à¤µ",
                    success: "à¤¬à¤§à¤¾à¤ˆ à¤¹à¥‹! à¤†à¤ªà¤¨à¥‡ à¤µà¤¿à¤­à¤µ à¤®à¤¾à¤°à¥à¤— à¤•à¤¾ à¤…à¤¨à¥à¤µà¥‡à¤·à¤£ à¤•à¤¿à¤¯à¤¾!",
                    reset: "à¤®à¤¾à¤°à¥à¤— à¤°à¥€à¤¸à¥‡à¤Ÿ à¤•à¤°à¥‡à¤‚"
                },
                gaussChallenge: {
                    title: "à¤—à¥‰à¤¸ à¤•à¤¾ à¤¨à¤¿à¤¯à¤® à¤šà¥à¤¨à¥Œà¤¤à¥€",
                    instruction: "à¤—à¤¾à¤‰à¤¸à¥€à¤¯à¤¨ à¤¸à¤¤à¤¹ à¤–à¥€à¤‚à¤šà¥‡à¤‚ à¤”à¤° à¤µà¤¿à¤¦à¥à¤¯à¥à¤¤ à¤ªà¥à¤°à¤µà¤¾à¤¹ à¤•à¤¾ à¤…à¤¨à¥à¤µà¥‡à¤·à¤£ à¤•à¤°à¥‡à¤‚!",
                    flux: "à¤µà¤¿à¤¦à¥à¤¯à¥à¤¤ à¤ªà¥à¤°à¤µà¤¾à¤¹",
                    enclosed: "à¤˜à¤¿à¤°à¤¾ à¤¹à¥à¤† à¤†à¤µà¥‡à¤¶",
                    success: "à¤¶à¤¾à¤¨à¤¦à¤¾à¤°! à¤†à¤ªà¤¨à¥‡ à¤—à¥‰à¤¸ à¤•à¤¾ à¤¨à¤¿à¤¯à¤® à¤¸à¤¹à¥€ à¤¢à¤‚à¤— à¤¸à¥‡ à¤²à¤¾à¤—à¥‚ à¤•à¤¿à¤¯à¤¾!",
                    reset: "à¤šà¥à¤¨à¥Œà¤¤à¥€ à¤°à¥€à¤¸à¥‡à¤Ÿ à¤•à¤°à¥‡à¤‚"
                },
                controls: {
                    play: "à¤–à¥‡à¤²à¥‡à¤‚",
                    pause: "à¤°à¥‹à¤•à¥‡à¤‚",
                    replay: "à¤«à¤¿à¤° à¤¸à¥‡ à¤–à¥‡à¤²à¥‡à¤‚",
                    next: "à¤…à¤—à¤²à¤¾"
                }
            },
            ori: {
                title: "à¬­à­Œà¬¤à¬¿à¬• à¬¬à¬¿à¬œà­à¬žà¬¾à¬¨ à¬…à¬­à¬¿à¬¯à¬¾à¬¨",
                subtitle: "à¬¬à¬¿à¬¦à­à­Ÿà­à¬¤à­ à¬†à¬¬à­‡à¬¶ à¬à¬¬à¬‚ à¬•à­à¬·à­‡à¬¤à­à¬° - à­§à­¨à¬® à¬¶à­à¬°à­‡à¬£à­€",
                levels: [
                    { name: "à¬•à­à¬·à­‡à¬¤à­à¬° à¬¦à­ƒà¬¶à­à­Ÿà¬•à¬¾à¬°à­€", desc: "à¬¬à¬¿à¬¦à­à­Ÿà­à¬¤à­ à¬•à­à¬·à­‡à¬¤à­à¬° à¬¸à­ƒà¬·à­à¬Ÿà¬¿ à¬•à¬°à¬¨à­à¬¤à­", icon: "âš¡" },
                    { name: "à¬•à­à¬²à¬®à­ à¬ªà¬°à­€à¬•à­à¬·à¬¾à¬—à¬¾à¬°", desc: "à¬¶à¬•à­à¬¤à¬¿ à¬¸à¬¹à¬¿à¬¤ à¬ªà¬°à­€à¬•à­à¬·à¬¾ à¬•à¬°à¬¨à­à¬¤à­", icon: "ðŸ”¬" },
                    { name: "à¬—à¬¾à¬‰à¬¸à­ à¬šà­à­Ÿà¬¾à¬²à­‡à¬žà­à¬œà­", desc: "à¬ªà­à¬°à¬¬à¬¾à¬¹ à¬—à¬£à¬¨à¬¾à¬°à­‡ à¬®à¬¾à¬¸à­à¬Ÿà¬°à­ à¬¹à­à¬…à¬¨à­à¬¤à­", icon: "ðŸŒ€" },
                    { name: "à¬¬à¬¿à¬­à¬¬ à¬®à¬¾à¬°à­à¬—", desc: "à¬¬à¬¿à¬­à¬¬ à¬°à­‡à¬–à¬¾ à¬…à¬¨à­à¬¸à¬¾à¬°à­‡ à¬šà¬¾à¬²à¬¨à­à¬¤à­", icon: "ðŸŽ¯" }
                ],
                fieldVisualizer: {
                    title: "à¬¬à¬¿à¬¦à­à­Ÿà­à¬¤à­ à¬•à­à¬·à­‡à¬¤à­à¬° à¬¦à­ƒà¬¶à­à­Ÿà¬•à¬¾à¬°à­€",
                    instruction: "à¬¬à¬¿à¬¦à­à­Ÿà­à¬¤à­ à¬•à­à¬·à­‡à¬¤à­à¬° à¬¸à­ƒà¬·à­à¬Ÿà¬¿ à¬•à¬°à¬¿à¬¬à¬¾à¬•à­ à¬†à¬¬à­‡à¬¶ à¬°à¬–à¬¨à­à¬¤à­à¥¤ à¬¬à¬¿à¬­à¬¿à¬¨à­à¬¨ à¬¬à¬¿à¬¨à­à­Ÿà¬¾à¬¸ à¬šà­‡à¬·à­à¬Ÿà¬¾ à¬•à¬°à¬¨à­à¬¤à­!",
                    positive: "à¬¯à­‹à¬—à¬¾à¬¤à­à¬®à¬• à¬¯à­‹à¬¡à¬¼à¬¨à­à¬¤à­",
                    negative: "à¬‹à¬£à¬¾à¬¤à­à¬®à¬• à¬¯à­‹à¬¡à¬¼à¬¨à­à¬¤à­",
                    clear: "à¬¸à¬¬à­ à¬¸à¬«à¬¾ à¬•à¬°à¬¨à­à¬¤à­",
                    charges: "à¬†à¬¬à­‡à¬¶",
                    success: "à¬…à¬¦à­à¬­à­à¬¤! à¬†à¬ªà¬£ à¬à¬• à¬¬à¬¿à¬¦à­à­Ÿà­à¬¤à­ à¬•à­à¬·à­‡à¬¤à­à¬° à¬¸à­ƒà¬·à­à¬Ÿà¬¿ à¬•à¬°à¬¿à¬›à¬¨à­à¬¤à¬¿!",
                    reset: "à¬•à­à¬·à­‡à¬¤à­à¬° à¬ªà­à¬¨à¬ƒà¬¸à­à¬¥à¬¾à¬ªà¬¨ à¬•à¬°à¬¨à­à¬¤à­"
                },
                coulombsLab: {
                    title: "à¬•à­à¬²à¬®à­ à¬¨à¬¿à­Ÿà¬® à¬ªà¬°à­€à¬•à­à¬·à¬¾à¬—à¬¾à¬°",
                    instruction: "à¬¶à¬•à­à¬¤à¬¿ à¬•à¬¿à¬ªà¬°à¬¿ à¬ªà¬°à¬¿à¬¬à¬°à­à¬¤à­à¬¤à¬¨ à¬¹à­à¬ à¬¦à­‡à¬–à¬¿à¬¬à¬¾à¬•à­ à¬†à¬¬à­‡à¬¶ à¬Ÿà¬¾à¬£à¬¿ à¬†à¬£à¬¨à­à¬¤à­à¥¤ à¬¬à¬¿à¬­à¬¿à¬¨à­à¬¨ à¬¬à¬¿à¬¨à­à­Ÿà¬¾à¬¸ à¬šà­‡à¬·à­à¬Ÿà¬¾ à¬•à¬°à¬¨à­à¬¤à­!",
                    charge1: "à¬†à¬¬à­‡à¬¶ à­§",
                    charge2: "à¬†à¬¬à­‡à¬¶ à­¨",
                    distance: "à¬¦à­‚à¬°à¬¤à¬¾",
                    force: "à¬¶à¬•à­à¬¤à¬¿",
                    success: "à¬…à¬¦à­à¬­à­à¬¤! à¬†à¬ªà¬£ à¬•à­à¬²à¬®à­ à¬¨à¬¿à­Ÿà¬® à¬¶à¬¿à¬–à¬¿à¬›à¬¨à­à¬¤à¬¿!",
                    reset: "à¬ªà¬°à­€à¬•à­à¬·à¬¾ à¬ªà­à¬¨à¬ƒà¬¸à­à¬¥à¬¾à¬ªà¬¨ à¬•à¬°à¬¨à­à¬¤à­"
                },
                potentialMaze: {
                    title: "à¬¬à¬¿à¬¦à­à­Ÿà­à¬¤à­ à¬¬à¬¿à¬­à¬¬ à¬®à¬¾à¬°à­à¬—",
                    instruction: "à¬®à¬¾à¬°à­à¬— à¬šà¬¾à¬²à¬¨à­à¬¤à­ à¬à¬¬à¬‚ à¬†à¬¬à­‡à¬¶ à¬Ÿà¬¾à¬£à¬¿ à¬¬à¬¿à¬¦à­à­Ÿà­à¬¤à­ à¬¬à¬¿à¬­à¬¬à¬•à­ à¬…à¬¨à­à­±à­‡à¬·à¬£ à¬•à¬°à¬¨à­à¬¤à­!",
                    potential: "à¬¬à¬°à­à¬¤à­à¬¤à¬®à¬¾à¬¨ à¬¬à¬¿à¬­à¬¬",
                    success: "à¬…à¬­à¬¿à¬¨à¬¨à­à¬¦à¬¨! à¬†à¬ªà¬£ à¬¬à¬¿à¬­à¬¬ à¬®à¬¾à¬°à­à¬—à¬•à­ à¬…à¬¨à­à­±à­‡à¬·à¬£ à¬•à¬°à¬¿à¬›à¬¨à­à¬¤à¬¿!",
                    reset: "à¬®à¬¾à¬°à­à¬— à¬ªà­à¬¨à¬ƒà¬¸à­à¬¥à¬¾à¬ªà¬¨ à¬•à¬°à¬¨à­à¬¤à­"
                },
                gaussChallenge: {
                    title: "à¬—à¬¾à¬‰à¬¸à­ à¬¨à¬¿à­Ÿà¬® à¬šà­à­Ÿà¬¾à¬²à­‡à¬žà­à¬œà­",
                    instruction: "à¬—à¬¾à¬‰à¬¸à¬¿à¬†à¬¨à­ à¬ªà­ƒà¬·à­à¬ à¬•à­ à¬Ÿà¬¾à¬£à¬¿ à¬à¬¬à¬‚ à¬¬à¬¿à¬¦à­à­Ÿà­à¬¤à­ à¬ªà­à¬°à¬¬à¬¾à¬¹à¬•à­ à¬…à¬¨à­à­±à­‡à¬·à¬£ à¬•à¬°à¬¨à­à¬¤à­!",
                    flux: "à¬¬à¬¿à¬¦à­à­Ÿà­à¬¤à­ à¬ªà­à¬°à¬¬à¬¾à¬¹",
                    enclosed: "à¬¬à­‡à¬¢à¬¼à¬¾ à¬†à¬¬à­‡à¬¶",
                    success: "à¬¬à¬¢à¬¼à¬¿à¬†! à¬†à¬ªà¬£ à¬—à¬¾à¬‰à¬¸à­ à¬¨à¬¿à­Ÿà¬® à¬¸à¬ à¬¿à¬•à­ à¬­à¬¾à¬¬à¬°à­‡ à¬ªà­à¬°à­Ÿà­‹à¬— à¬•à¬°à¬¿à¬›à¬¨à­à¬¤à¬¿!",
                    reset: "à¬šà­à­Ÿà¬¾à¬²à­‡à¬žà­à¬œà­ à¬ªà­à¬¨à¬ƒà¬¸à­à¬¥à¬¾à¬ªà¬¨ à¬•à¬°à¬¨à­à¬¤à­"
                },
                controls: {
                    play: "à¬–à­‡à¬³à¬¨à­à¬¤à­",
                    pause: "à¬¬à¬¿à¬°à¬¾à¬®",
                    replay: "à¬ªà­à¬¨à¬°à­à¬¬à¬¾à¬° à¬–à­‡à¬³à¬¨à­à¬¤à­",
                    next: "à¬ªà¬°à¬¬à¬°à­à¬¤à­à¬¤à­€"
                }
            }
        };

        // Field Visualizer Component
        const FieldVisualizer = ({ translation, onComplete }) => {
            const [charges, setCharges] = useState([]);
            const [fieldLines, setFieldLines] = useState([]);
            const [forceVectors, setForceVectors] = useState([]);
            const [dragging, setDragging] = useState(null);
            const [showSuccess, setShowSuccess] = useState(false);
            const canvasRef = useRef(null);
            
            // Add a new charge to the canvas
            const addCharge = (type) => {
                if (!canvasRef.current) return;
                
                const rect = canvasRef.current.getBoundingClientRect();
                const x = rect.width / 2;
                const y = rect.height / 2;
                
                const newCharge = {
                    id: Date.now(),
                    x,
                    y,
                    value: type === 'positive' ? 5 : -5
                };
                
                setCharges(prev => [...prev, newCharge]);
                
                // Show success after adding first charge
                if (charges.length === 0) {
                    setShowSuccess(true);
                    onComplete();
                }
            };
            
            // Clear all charges
            const clearCharges = () => {
                setCharges([]);
                setFieldLines([]);
                setForceVectors([]);
                setShowSuccess(false);
            };
            
            // Calculate and draw field lines
            useEffect(() => {
                if (charges.length === 0) {
                    setFieldLines([]);
                    setForceVectors([]);
                    return;
                }
                
                const newFieldLines = [];
                const numLines = 8; // Number of field lines per charge
                
                charges.forEach(charge => {
                    for (let i = 0; i < numLines; i++) {
                        const angle = (i / numLines) * 2 * Math.PI;
                        const startRadius = 30; // Starting radius from charge
                        
                        const startX = charge.x + startRadius * Math.cos(angle);
                        const startY = charge.y + startRadius * Math.sin(angle);
                        
                        // Create a field line with multiple points
                        const linePoints = [{ x: startX, y: startY }];
                        let currentX = startX;
                        let currentY = startY;
                        
                        // Trace the field line
                        for (let step = 0; step < 50; step++) {
                            let Ex = 0;
                            let Ey = 0;
                            
                            // Calculate electric field at current point
                            charges.forEach(c => {
                                const dx = currentX - c.x;
                                const dy = currentY - c.y;
                                const rSquared = dx * dx + dy * dy;
                                
                                if (rSquared > 1) { // Avoid division by zero
                                    const r = Math.sqrt(rSquared);
                                    const E = c.value / rSquared;
                                    
                                    Ex += E * dx / r;
                                    Ey += E * dy / r;
                                }
                            });
                            
                            // Normalize and scale
                            const E = Math.sqrt(Ex * Ex + Ey * Ey);
                            if (E > 0) {
                                const stepSize = 10;
                                currentX += stepSize * Ex / E;
                                currentY += stepSize * Ey / E;
                                
                                // Check if point is within canvas
                                if (canvasRef.current) {
                                    const rect = canvasRef.current.getBoundingClientRect();
                                    if (currentX < 0 || currentX > rect.width || 
                                        currentY < 0 || currentY > rect.height) {
                                        break;
                                    }
                                }
                                
                                linePoints.push({ x: currentX, y: currentY });
                            } else {
                                break;
                            }
                        }
                        
                        if (linePoints.length > 1) {
                            newFieldLines.push({
                                id: `${charge.id}-${i}`,
                                points: linePoints,
                                chargeType: charge.value > 0 ? 'positive' : 'negative'
                            });
                        }
                    }
                });
                
                setFieldLines(newFieldLines);
                
                // Calculate force vectors between charges
                const newForceVectors = [];
                const k = 8.99e9; // Coulomb's constant
                
                for (let i = 0; i < charges.length; i++) {
                    for (let j = i + 1; j < charges.length; j++) {
                        const charge1 = charges[i];
                        const charge2 = charges[j];
                        
                        const dx = charge2.x - charge1.x;
                        const dy = charge2.y - charge1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            // Calculate force magnitude (scaled for visualization)
                            const forceMagnitude = Math.abs(k * charge1.value * charge2.value / (distance * distance)) * 1e-6;
                            const maxVectorLength = 100; // Maximum vector length for visualization
                            const vectorLength = Math.min(forceMagnitude * 10, maxVectorLength);
                            
                            const angle = Math.atan2(dy, dx);
                            const isAttraction = charge1.value * charge2.value < 0;
                            
                            // Vector from charge1 to charge2
                            newForceVectors.push({
                                id: `${charge1.id}-${charge2.id}`,
                                startX: charge1.x,
                                startY: charge1.y,
                                length: vectorLength,
                                angle: angle,
                                type: isAttraction ? 'attraction' : 'repulsion'
                            });
                            
                            // Vector from charge2 to charge1
                            newForceVectors.push({
                                id: `${charge2.id}-${charge1.id}`,
                                startX: charge2.x,
                                startY: charge2.y,
                                length: vectorLength,
                                angle: angle + Math.PI,
                                type: isAttraction ? 'attraction' : 'repulsion'
                            });
                        }
                    }
                }
                
                setForceVectors(newForceVectors);
            }, [charges]);
            
            const handleMouseDown = (e, chargeId) => {
                e.preventDefault();
                setDragging(chargeId);
            };
            
            const handleMouseMove = (e) => {
                if (!dragging || !canvasRef.current) return;
                
                const rect = canvasRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Keep charges within bounds
                const boundedX = Math.max(25, Math.min(rect.width - 25, x));
                const boundedY = Math.max(25, Math.min(rect.height - 25, y));
                
                setCharges(prev => prev.map(charge => 
                    charge.id === dragging 
                        ? { ...charge, x: boundedX, y: boundedY } 
                        : charge
                ));
            };
            
            const handleMouseUp = () => {
                setDragging(null);
            };
            
            const resetField = () => {
                setCharges([]);
                setFieldLines([]);
                setForceVectors([]);
                setShowSuccess(false);
            };
            
            return (
                <div className="puzzle-container">
                    <h3 className="puzzle-title">{translation.fieldVisualizer.title}</h3>
                    <p style={{ textAlign: 'center', marginBottom: '20px' }}>
                        {translation.fieldVisualizer.instruction}
                    </p>
                    
                    <div className="field-visualizer-container">
                        <div 
                            ref={canvasRef}
                            className="field-canvas"
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                        >
                            {/* Field lines */}
                            {fieldLines.map(line => (
                                <React.Fragment key={line.id}>
                                    {line.points.slice(0, -1).map((point, index) => {
                                        const nextPoint = line.points[index + 1];
                                        const dx = nextPoint.x - point.x;
                                        const dy = nextPoint.y - point.y;
                                        const length = Math.sqrt(dx * dx + dy * dy);
                                        const angle = Math.atan2(dy, dx);
                                        
                                        return (
                                            <React.Fragment key={`${line.id}-${index}`}>
                                                <div
                                                    className="field-line"
                                                    style={{
                                                        left: point.x,
                                                        top: point.y,
                                                        width: length,
                                                        transform: `rotate(${angle}rad)`,
                                                        transformOrigin: '0 50%',
                                                        background: line.chargeType === 'positive' 
                                                            ? 'linear-gradient(90deg, rgba(255, 107, 107, 0.7), rgba(238, 90, 36, 0.7))'
                                                            : 'linear-gradient(90deg, rgba(78, 205, 196, 0.7), rgba(68, 163, 170, 0.7))'
                                                    }}
                                                />
                                                <div
                                                    className="field-arrow"
                                                    style={{
                                                        left: nextPoint.x - 8,
                                                        top: nextPoint.y - 5,
                                                        borderLeftColor: line.chargeType === 'positive' 
                                                            ? 'rgba(238, 90, 36, 0.7)'
                                                            : 'rgba(68, 163, 170, 0.7)'
                                                    }}
                                                />
                                            </React.Fragment>
                                        );
                                    })}
                                </React.Fragment>
                            ))}
                            
                            {/* Force vectors */}
                            {forceVectors.map(vector => (
                                <div
                                    key={vector.id}
                                    className={`force-vector ${vector.type}`}
                                    style={{
                                        left: vector.startX,
                                        top: vector.startY,
                                        width: vector.length,
                                        transform: `rotate(${vector.angle}rad)`,
                                        transformOrigin: '0 50%'
                                    }}
                                />
                            ))}
                            
                            {/* Charges */}
                            {charges.map(charge => (
                                <div
                                    key={charge.id}
                                    className={`field-charge ${charge.value > 0 ? 'positive' : 'negative'} ${dragging === charge.id ? 'dragging' : ''}`}
                                    style={{
                                        left: charge.x - 25,
                                        top: charge.y - 25
                                    }}
                                    onMouseDown={(e) => handleMouseDown(e, charge.id)}
                                >
                                    {charge.value > 0 ? '+' : '-'}{Math.abs(charge.value)}
                                </div>
                            ))}
                            
                            {/* Charge info */}
                            <div className="field-info" style={{ position: 'absolute', top: '20px', left: '20px' }}>
                                <div className="field-info-label">{translation.fieldVisualizer.charges}</div>
                                <div className="field-info-value">{charges.length}</div>
                            </div>
                        </div>
                        
                        <div className="field-controls">
                            <button className="field-btn" onClick={() => addCharge('positive')}>
                                <span>+</span> {translation.fieldVisualizer.positive}
                            </button>
                            <button className="field-btn" onClick={() => addCharge('negative')}>
                                <span>-</span> {translation.fieldVisualizer.negative}
                            </button>
                            <button className="field-btn" onClick={clearCharges}>
                                {translation.fieldVisualizer.clear}
                            </button>
                        </div>
                    </div>
                    
                    {showSuccess && (
                        <div className="success-message">
                            {translation.fieldVisualizer.success}
                        </div>
                    )}
                    
                    <div className="controls-container">
                        <button className="control-btn" onClick={resetField}>
                            {translation.fieldVisualizer.reset}
                        </button>
                    </div>
                </div>
            );
        };

        const CoulombsLab = ({ translation, onComplete }) => {
            const [charge1, setCharge1] = useState({ x: 150, y: 200, value: 5 });
            const [charge2, setCharge2] = useState({ x: 450, y: 200, value: -3 });
            const [dragging, setDragging] = useState(null);
            const [showSuccess, setShowSuccess] = useState(false);
            const [hasInteracted, setHasInteracted] = useState(false);
            const visualizationRef = useRef(null);
            
            // Calculate distance between charges
            const distance = Math.sqrt(
                Math.pow(charge2.x - charge1.x, 2) + 
                Math.pow(charge2.y - charge1.y, 2)
            );
            
            // Calculate force using Coulomb's law (simplified for visualization)
            const k = 8.99e9; // Coulomb's constant
            const force = Math.abs(k * Math.abs(charge1.value * charge2.value) / Math.pow(distance / 100, 2)) * 1e-6;
            
            const handleMouseDown = (e, chargeId) => {
                e.preventDefault();
                setDragging(chargeId);
            };
            
            const handleMouseMove = (e) => {
                if (!dragging || !visualizationRef.current) return;
                
                const rect = visualizationRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Keep charges within bounds
                const boundedX = Math.max(40, Math.min(rect.width - 40, x));
                const boundedY = Math.max(40, Math.min(rect.height - 40, y));
                
                if (dragging === 'charge1') {
                    setCharge1(prev => ({ ...prev, x: boundedX, y: boundedY }));
                } else if (dragging === 'charge2') {
                    setCharge2(prev => ({ ...prev, x: boundedX, y: boundedY }));
                }
            };
            
            const handleMouseUp = () => {
                if (dragging && !hasInteracted) {
                    setHasInteracted(true);
                    setShowSuccess(true);
                    onComplete();
                }
                setDragging(null);
            };
            
            const resetExperiment = () => {
                setCharge1({ x: 150, y: 200, value: 5 });
                setCharge2({ x: 450, y: 200, value: -3 });
                setShowSuccess(false);
                setHasInteracted(false);
            };
            
            // Calculate force vector properties
            const forceDirection = charge1.value * charge2.value > 0 ? 'repulsion' : 'attraction';
            const forceAngle = Math.atan2(charge2.y - charge1.y, charge2.x - charge1.x);
            const forceLength = Math.min(distance * 0.4, 150); // Scale force vector for visualization
            
            return (
                <div className="puzzle-container">
                    <h3 className="puzzle-title">{translation.coulombsLab.title}</h3>
                    <p style={{ textAlign: 'center', marginBottom: '20px' }}>
                        {translation.coulombsLab.instruction}
                    </p>
                    
                    <div className="coulombs-lab-container">
                        <div 
                            ref={visualizationRef}
                            className="force-visualization"
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                        >
                            {/* Distance line */}
                            <div 
                                className="distance-line"
                                style={{
                                    left: charge1.x,
                                    top: charge1.y,
                                    width: distance,
                                    transform: `rotate(${forceAngle}rad)`,
                                    transformOrigin: '0 50%'
                                }}
                            />
                            
                            {/* Distance label */}
                            <div 
                                className="distance-label"
                                style={{
                                    left: (charge1.x + charge2.x) / 2 - 30,
                                    top: (charge1.y + charge2.y) / 2 - 30
                                }}
                            >
                                {distance.toFixed(0)} mm
                            </div>
                            
                            {/* Force vectors */}
                            <div 
                                className={`force-vector ${forceDirection}`}
                                style={{
                                    left: charge1.x + 40,
                                    top: charge1.y,
                                    width: forceLength,
                                    transform: `rotate(${forceAngle}rad)`,
                                    transformOrigin: '0 50%'
                                }}
                            />
                            
                            <div 
                                className={`force-vector ${forceDirection}`}
                                style={{
                                    left: charge2.x - 40 - forceLength,
                                    top: charge2.y,
                                    width: forceLength,
                                    transform: `rotate(${forceAngle + Math.PI}rad)`,
                                    transformOrigin: '0 50%'
                                }}
                            />
                            
                            {/* Charge 1 */}
                            <div
                                className={`charge-ball positive ${dragging === 'charge1' ? 'dragging' : ''}`}
                                style={{
                                    left: charge1.x - 40,
                                    top: charge1.y - 40
                                }}
                                onMouseDown={(e) => handleMouseDown(e, 'charge1')}
                            >
                                +{Math.abs(charge1.value)}
                            </div>
                            
                            {/* Charge 2 */}
                            <div
                                className={`charge-ball negative ${dragging === 'charge2' ? 'dragging' : ''}`}
                                style={{
                                    left: charge2.x - 40,
                                    top: charge2.y - 40
                                }}
                                onMouseDown={(e) => handleMouseDown(e, 'charge2')}
                            >
                                -{Math.abs(charge2.value)}
                            </div>
                        </div>
                        
                        <div className="controls-panel">
                            <div className="control-group">
                                <label className="control-label">
                                    <span className="control-icon positive">+</span>
                                    {translation.coulombsLab.charge1}
                                </label>
                                <div className="slider-container">
                                    <input
                                        type="range"
                                        className="slider"
                                        min="1"
                                        max="10"
                                        value={Math.abs(charge1.value)}
                                        onChange={(e) => {
                                            setCharge1(prev => ({ 
                                                ...prev, 
                                                value: prev.value > 0 ? parseInt(e.target.value) : -parseInt(e.target.value)
                                            }));
                                            if (!hasInteracted) {
                                                setHasInteracted(true);
                                                setShowSuccess(true);
                                                onComplete();
                                            }
                                        }}
                                    />
                                    <div className="slider-value">{Math.abs(charge1.value)} Î¼C</div>
                                </div>
                            </div>
                            
                            <div className="control-group">
                                <label className="control-label">
                                    <span className="control-icon negative">-</span>
                                    {translation.coulombsLab.charge2}
                                </label>
                                <div className="slider-container">
                                    <input
                                        type="range"
                                        className="slider"
                                        min="1"
                                        max="10"
                                        value={Math.abs(charge2.value)}
                                        onChange={(e) => {
                                            setCharge2(prev => ({ 
                                                ...prev, 
                                                value: prev.value > 0 ? parseInt(e.target.value) : -parseInt(e.target.value)
                                            }));
                                            if (!hasInteracted) {
                                                setHasInteracted(true);
                                                setShowSuccess(true);
                                                onComplete();
                                            }
                                        }}
                                    />
                                    <div className="slider-value">{Math.abs(charge2.value)} Î¼C</div>
                                </div>
                            </div>
                            
                            <div className="control-group">
                                <label className="control-label">
                                    <span className="control-icon distance">â†”</span>
                                    {translation.coulombsLab.distance}
                                </label>
                                <div className="slider-container">
                                    <div className="slider-value">{distance.toFixed(0)} mm</div>
                                </div>
                            </div>
                            
                            <div className="result-display">
                                <div className="result-label">{translation.coulombsLab.force}</div>
                                <div className="result-value">
                                    {force.toFixed(2)}
                                    <span className="result-unit">N</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    {showSuccess && (
                        <div className="success-message">
                            {translation.coulombsLab.success}
                        </div>
                    )}
                    
                    <div className="controls-container">
                        <button className="control-btn" onClick={resetExperiment}>
                            {translation.coulombsLab.reset}
                        </button>
                    </div>
                </div>
            );
        };

        const PotentialMaze = ({ translation, onComplete }) => {
            const [player, setPlayer] = useState({ x: 30, y: 30 });
            const [charges, setCharges] = useState([
                { id: 1, x: 200, y: 150, value: 5 },
                { id: 2, x: 400, y: 300, value: -3 }
            ]);
            const [dragging, setDragging] = useState(null);
            const [showSuccess, setShowSuccess] = useState(false);
            const [hasInteracted, setHasInteracted] = useState(false);
            const mazeRef = useRef(null);
            
            // Maze layout (1 = wall, 0 = path, 2 = end)
            const maze = [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 0, 1, 1, 1, 0, 1],
                [1, 0, 1, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 0, 1, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
                [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                [1, 0, 1, 0, 0, 0, 1, 0, 2, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ];
            
            // Calculate potential at player position
            const calculatePotential = () => {
                const k = 8.99e9; // Coulomb's constant
                let potential = 0;
                
                charges.forEach(charge => {
                    const dx = player.x - charge.x;
                    const dy = player.y - charge.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 5) { // Avoid division by zero
                        // Scale down for visualization
                        const scale = 1e-9;
                        potential += k * charge.value / distance * scale;
                    }
                });
                
                return potential;
            };
            
            const potential = calculatePotential();
            
            const handleKeyDown = (e) => {
                const step = 10;
                let newX = player.x;
                let newY = player.y;
                
                switch (e.key) {
                    case 'ArrowUp':
                        newY -= step;
                        break;
                    case 'ArrowDown':
                        newY += step;
                        break;
                    case 'ArrowLeft':
                        newX -= step;
                        break;
                    case 'ArrowRight':
                        newX += step;
                        break;
                    default:
                        return;
                }
                
                // Check if new position is valid (not in a wall)
                if (mazeRef.current) {
                    const cellSize = mazeRef.current.offsetWidth / 10;
                    const col = Math.floor(newX / cellSize);
                    const row = Math.floor(newY / cellSize);
                    
                    if (row >= 0 && row < 10 && col >= 0 && col < 10 && maze[row][col] !== 1) {
                        setPlayer({ x: newX, y: newY });
                        
                        // Mark as interacted after moving 5 steps
                        if (!hasInteracted) {
                            const steps = Math.floor(Math.sqrt(Math.pow(newX - 30, 2) + Math.pow(newY - 30, 2)) / step);
                            if (steps >= 5) {
                                setHasInteracted(true);
                                setShowSuccess(true);
                                onComplete();
                            }
                        }
                    }
                }
            };
            
            const handleMouseDown = (e, chargeId) => {
                e.preventDefault();
                setDragging(chargeId);
            };
            
            const handleMouseMove = (e) => {
                if (!dragging || !mazeRef.current) return;
                
                const rect = mazeRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Keep charges within bounds
                const boundedX = Math.max(20, Math.min(rect.width - 20, x));
                const boundedY = Math.max(20, Math.min(rect.height - 20, y));
                
                setCharges(prev => prev.map(charge => 
                    charge.id === dragging 
                        ? { ...charge, x: boundedX, y: boundedY } 
                        : charge
                ));
            };
            
            const handleMouseUp = () => {
                if (dragging && !hasInteracted) {
                    setHasInteracted(true);
                    setShowSuccess(true);
                    onComplete();
                }
                setDragging(null);
            };
            
            const resetMaze = () => {
                setPlayer({ x: 30, y: 30 });
                setCharges([
                    { id: 1, x: 200, y: 150, value: 5 },
                    { id: 2, x: 400, y: 300, value: -3 }
                ]);
                setShowSuccess(false);
                setHasInteracted(false);
            };
            
            useEffect(() => {
                document.addEventListener('keydown', handleKeyDown);
                return () => {
                    document.removeEventListener('keydown', handleKeyDown);
                };
            }, [hasInteracted]);
            
            // Render maze cells
            const renderMaze = () => {
                if (!mazeRef.current) return null;
                
                const cellSize = mazeRef.current.offsetWidth / 10;
                const cells = [];
                
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 10; col++) {
                        const cellType = maze[row][col];
                        let className = 'maze-cell';
                        
                        if (cellType === 1) {
                            className += ' wall';
                        } else if (row === 1 && col === 1) {
                            className += ' start';
                        } else if (cellType === 2) {
                            className += ' end';
                        }
                        
                        cells.push(
                            <div
                                key={`${row}-${col}`}
                                className={className}
                                style={{
                                    position: 'absolute',
                                    left: col * cellSize,
                                    top: row * cellSize,
                                    width: cellSize,
                                    height: cellSize
                                }}
                            />
                        );
                    }
                }
                
                return cells;
            };
            
            return (
                <div className="puzzle-container">
                    <h3 className="puzzle-title">{translation.potentialMaze.title}</h3>
                    <p style={{ textAlign: 'center', marginBottom: '20px' }}>
                        {translation.potentialMaze.instruction}
                    </p>
                    
                    <div className="maze-container">
                        <div 
                            ref={mazeRef}
                            className="maze-visualization"
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                        >
                            <div className="maze-grid">
                                {renderMaze()}
                            </div>
                            
                            {/* Player */}
                            <div
                                className="player"
                                style={{
                                    left: player.x - 15,
                                    top: player.y - 15,
                                    background: potential > 0 
                                        ? 'radial-gradient(circle at 30% 30%, #ff6b6b, #ee5a24)' 
                                        : potential < 0 
                                            ? 'radial-gradient(circle at 30% 30%, #4ecdc4, #44a3aa)'
                                            : 'radial-gradient(circle at 30% 30%, #feca57, #ff9ff3)'
                                }}
                            >
                                P
                            </div>
                            
                            {/* Charges */}
                            {charges.map(charge => (
                                <div
                                    key={charge.id}
                                    className={`maze-charge ${charge.value > 0 ? 'positive' : 'negative'} ${dragging === charge.id ? 'dragging' : ''}`}
                                    style={{
                                        left: charge.x - 20,
                                        top: charge.y - 20
                                    }}
                                    onMouseDown={(e) => handleMouseDown(e, charge.id)}
                                >
                                    {charge.value > 0 ? '+' : '-'}{Math.abs(charge.value)}
                                </div>
                            ))}
                            
                            {/* Potential indicator */}
                            <div className="potential-indicator">
                                <div className="potential-label">{translation.potentialMaze.potential}</div>
                                <div className="potential-value">{potential.toFixed(2)} V</div>
                            </div>
                        </div>
                    </div>
                    
                    {showSuccess && (
                        <div className="success-message">
                            {translation.potentialMaze.success}
                        </div>
                    )}
                    
                    <div className="controls-container">
                        <button className="control-btn" onClick={resetMaze}>
                            {translation.potentialMaze.reset}
                        </button>
                    </div>
                </div>
            );
        };

        const GaussChallenge = ({ translation, onComplete }) => {
            const [charges, setCharges] = useState([
                { id: 1, x: 150, y: 150, value: 5 },
                { id: 2, x: 350, y: 250, value: -3 },
                { id: 3, x: 250, y: 350, value: 2 }
            ]);
            const [gaussianSurface, setGaussianSurface] = useState({ x: 250, y: 250, radius: 100 });
            const [draggingSurface, setDraggingSurface] = useState(false);
            const [showSuccess, setShowSuccess] = useState(false);
            const [hasInteracted, setHasInteracted] = useState(false);
            const gaussRef = useRef(null);
            
            // Calculate enclosed charge and flux
            const calculateEnclosedCharge = () => {
                let enclosedCharge = 0;
                
                charges.forEach(charge => {
                    const dx = charge.x - gaussianSurface.x;
                    const dy = charge.y - gaussianSurface.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < gaussianSurface.radius) {
                        enclosedCharge += charge.value;
                    }
                });
                
                return enclosedCharge;
            };
            
            const enclosedCharge = calculateEnclosedCharge();
            
            // Calculate flux (Gauss's Law: Î¦ = Q_enclosed / Îµâ‚€)
            const epsilon0 = 8.85e-12; // Vacuum permittivity (F/m)
            const flux = enclosedCharge / epsilon0;
            
            const handleMouseDown = (e) => {
                if (!gaussRef.current) return;
                
                const rect = gaussRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const dx = x - gaussianSurface.x;
                const dy = y - gaussianSurface.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Check if click is on the Gaussian surface
                if (Math.abs(distance - gaussianSurface.radius) < 10) {
                    setDraggingSurface(true);
                }
            };
            
            const handleMouseMove = (e) => {
                if (!draggingSurface || !gaussRef.current) return;
                
                const rect = gaussRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Keep Gaussian surface within bounds
                const boundedX = Math.max(gaussianSurface.radius, Math.min(rect.width - gaussianSurface.radius, x));
                const boundedY = Math.max(gaussianSurface.radius, Math.min(rect.height - gaussianSurface.radius, y));
                
                setGaussianSurface(prev => ({ ...prev, x: boundedX, y: boundedY }));
            };
            
            const handleMouseUp = () => {
                if (draggingSurface && !hasInteracted) {
                    setHasInteracted(true);
                    setShowSuccess(true);
                    onComplete();
                }
                setDraggingSurface(false);
            };
            
            const resetChallenge = () => {
                setCharges([
                    { id: 1, x: 150, y: 150, value: 5 },
                    { id: 2, x: 350, y: 250, value: -3 },
                    { id: 3, x: 250, y: 350, value: 2 }
                ]);
                setGaussianSurface({ x: 250, y: 250, radius: 100 });
                setShowSuccess(false);
                setHasInteracted(false);
            };
            
            return (
                <div className="puzzle-container">
                    <h3 className="puzzle-title">{translation.gaussChallenge.title}</h3>
                    <p style={{ textAlign: 'center', marginBottom: '20px' }}>
                        {translation.gaussChallenge.instruction}
                    </p>
                    
                    <div className="gauss-container">
                        <div 
                            ref={gaussRef}
                            className="gauss-visualization"
                            onMouseDown={handleMouseDown}
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                        >
                            {/* Charges */}
                            {charges.map(charge => (
                                <div
                                    key={charge.id}
                                    className={`gauss-charge ${charge.value > 0 ? 'positive' : 'negative'}`}
                                    style={{
                                        left: charge.x - 25,
                                        top: charge.y - 25
                                    }}
                                >
                                    {charge.value > 0 ? '+' : '-'}{Math.abs(charge.value)}
                                </div>
                            ))}
                            
                            {/* Gaussian surface */}
                            <div
                                className={`gaussian-surface ${draggingSurface ? 'dragging' : ''}`}
                                style={{
                                    left: gaussianSurface.x - gaussianSurface.radius,
                                    top: gaussianSurface.y - gaussianSurface.radius,
                                    width: gaussianSurface.radius * 2,
                                    height: gaussianSurface.radius * 2,
                                    borderColor: enclosedCharge > 0 ? '#ff6b6b' : enclosedCharge < 0 ? '#4ecdc4' : '#667eea',
                                    backgroundColor: enclosedCharge > 0 
                                        ? 'rgba(255, 107, 107, 0.1)' 
                                        : enclosedCharge < 0 
                                            ? 'rgba(78, 205, 196, 0.1)'
                                            : 'rgba(102, 126, 234, 0.1)'
                                }}
                            />
                            
                            {/* Flux indicator */}
                            <div className="flux-indicator">
                                <div className="flux-label">{translation.gaussChallenge.flux}</div>
                                <div className="flux-value">{(flux / 1e11).toFixed(2)} Ã—10Â¹Â¹ NÂ·mÂ²/C</div>
                                <div className="flux-label">{translation.gaussChallenge.enclosed}</div>
                                <div className="enclosed-value">{enclosedCharge.toFixed(2)} Î¼C</div>
                            </div>
                        </div>
                    </div>
                    
                    {showSuccess && (
                        <div className="success-message">
                            {translation.gaussChallenge.success}
                        </div>
                    )}
                    
                    <div className="controls-container">
                        <button className="control-btn" onClick={resetChallenge}>
                            {translation.gaussChallenge.reset}
                        </button>
                    </div>
                </div>
            );
        };

        const PhysicsAdventureGame = () => {
            const [language, setLanguage] = useState('eng');
            const [currentLevel, setCurrentLevel] = useState(0); // Start with Field Visualizer
            const [gameStatus, setGameStatus] = useState('playing');
            const [completedLevels, setCompletedLevels] = useState([]);
            
            const translation = translations[language];
            const levels = translation.levels;
            
            const handleLevelComplete = () => {
                // Mark the current level as completed
                if (!completedLevels.includes(currentLevel)) {
                    setCompletedLevels(prev => [...prev, currentLevel]);
                }
            };
            
            const goToNextLevel = () => {
                if (currentLevel < levels.length - 1) {
                    setCurrentLevel(prevLevel => prevLevel + 1);
                }
            };
            
            const handlePlay = () => {
                setGameStatus('playing');
            };
            
            const handlePause = () => {
                setGameStatus('paused');
            };
            
            const handleReplay = () => {
                setCurrentLevel(0);
                setCompletedLevels([]);
                setGameStatus('playing');
            };
            
            const changeLanguage = (lang) => {
                setLanguage(lang);
                setCurrentLevel(0);
                setCompletedLevels([]);
            };
            
            const renderCurrentLevel = () => {
                switch (currentLevel) {
                    case 0:
                        return <FieldVisualizer translation={translation} onComplete={handleLevelComplete} />;
                    case 1:
                        return <CoulombsLab translation={translation} onComplete={handleLevelComplete} />;
                    case 2:
                        return <GaussChallenge translation={translation} onComplete={handleLevelComplete} />;
                    case 3:
                        return <PotentialMaze translation={translation} onComplete={handleLevelComplete} />;
                    default:
                        return <FieldVisualizer translation={translation} onComplete={handleLevelComplete} />;
                }
            };
            
            return (
                <div className="game-container">
                    <div className="game-header">
                        <h1 className="game-title">{translation.title}</h1>
                        <p className="game-subtitle">{translation.subtitle}</p>
                        <div className="language-selector">
                            <span className="globe-icon">ðŸŒ</span>
                            <select 
                                value={language} 
                                onChange={(e) => changeLanguage(e.target.value)}
                                className="language-select"
                            >
                                {Object.keys(translations).map(lang => (
                                    <option key={lang} value={lang}>{lang.toUpperCase()}</option>
                                ))}
                            </select>
                        </div>
                    </div>
                    
                    <div className="game-content">
                        <div className="level-selector">
                            {levels.map((level, index) => (
                                <div
                                    key={index}
                                    className={`level-card ${currentLevel === index ? 'active' : ''} ${completedLevels.includes(index) ? 'completed' : ''}`}
                                    onClick={() => setCurrentLevel(index)}
                                >
                                    <div className="level-icon">{level.icon}</div>
                                    <div className="level-name">{level.name}</div>
                                    <div className="level-desc">{level.desc}</div>
                                </div>
                            ))}
                        </div>
                        
                        {renderCurrentLevel()}
                        
                        <div className="controls-container">
                            {gameStatus === 'paused' ? (
                                <button className="control-btn" onClick={handlePlay}>
                                    {translation.controls.play}
                                </button>
                            ) : (
                                <button className="control-btn" onClick={handlePause}>
                                    {translation.controls.pause}
                                </button>
                            )}
                            
                            <button className="control-btn" onClick={handleReplay}>
                                {translation.controls.replay}
                            </button>
                            
                            {completedLevels.includes(currentLevel) && currentLevel < levels.length - 1 && (
                                <button className="control-btn next-btn" onClick={goToNextLevel}>
                                    {translation.controls.next}
                                </button>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<PhysicsAdventureGame />, document.getElementById('root'));
    </script>
</body>
</html>