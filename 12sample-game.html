<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Adventure - Electric Charges and Fields</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 25px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 1200px;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .game-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .game-header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        .game-title {
            font-family: 'Orbitron', monospace;
            font-size: 32px;
            font-weight: 900;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            position: relative;
            z-index: 1;
        }
        
        .game-subtitle {
            font-size: 18px;
            opacity: 0.9;
            position: relative;
            z-index: 1;
        }
        
        .language-selector {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 2;
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            padding: 5px;
        }
        
        .globe-icon {
            margin-right: 8px;
            font-size: 18px;
        }
        
        .language-select {
            background: transparent;
            border: none;
            color: white;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            outline: none;
            padding: 5px 10px;
            border-radius: 20px;
            transition: background 0.3s;
        }
        
        .language-select:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .language-select option {
            background: #667eea;
            color: white;
        }
        
        .game-content {
            padding: 30px;
        }
        
        .level-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .level-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            padding: 20px;
            min-width: 200px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            border: 3px solid transparent;
            position: relative;
            overflow: hidden;
        }
        
        .level-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s;
        }
        
        .level-card:hover::before {
            left: 100%;
        }
        
        .level-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .level-card.active {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .level-card.completed {
            border-color: #4caf50;
        }
        
        .level-card.completed::after {
            content: '✓';
            position: absolute;
            top: 10px;
            right: 10px;
            background: #4caf50;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        
        .level-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        .level-name {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .level-desc {
            font-size: 14px;
            opacity: 0.8;
        }
        
        .puzzle-container {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .puzzle-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }
        
        .simulation-area {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        /* Field Visualizer Styles */
        .field-visualizer-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .field-canvas {
            height: 500px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            border: 2px solid #e0e0e0;
        }
        
        .field-charge {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: 700;
            color: white;
            cursor: move;
            transition: box-shadow 0.3s ease;
            z-index: 10;
            user-select: none;
        }
        
        .field-charge.positive {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ee5a24);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }
        
        .field-charge.negative {
            background: radial-gradient(circle at 30% 30%, #4ecdc4, #44a3aa);
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }
        
        .field-charge:hover {
            transform: scale(1.1);
        }
        
        .field-charge.dragging {
            transform: scale(1.2);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.3);
        }
        
        .field-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.7), rgba(118, 75, 162, 0.7));
            transform-origin: left center;
            z-index: 1;
        }
        
        .field-arrow {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid rgba(102, 126, 234, 0.7);
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            z-index: 2;
        }
        
        .force-vector {
            position: absolute;
            height: 4px;
            transform-origin: left center;
            z-index: 5;
        }
        
        .force-vector::after {
            content: '';
            position: absolute;
            right: -10px;
            top: -6px;
            width: 0;
            height: 0;
            border-left: 15px solid;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
        }
        
        .force-vector.attraction {
            background: linear-gradient(90deg, #4ecdc4, #44a3aa);
        }
        
        .force-vector.attraction::after {
            border-left-color: #44a3aa;
        }
        
        .force-vector.repulsion {
            background: linear-gradient(90deg, #ff6b6b, #ee5a24);
        }
        
        .force-vector.repulsion::after {
            border-left-color: #ee5a24;
        }
        
        .field-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .field-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 12px 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .field-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .field-btn.active {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a3aa 100%);
        }
        
        .field-info {
            background: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 3px 15px rgba(0, 0, 0, 0.08);
            text-align: center;
        }
        
        .field-info-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .field-info-value {
            font-size: 18px;
            font-weight: 700;
            color: #667eea;
        }
        
        /* Coulomb's Lab Enhanced Styles */
        .coulombs-lab-container {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        
        .force-visualization {
            height: 400px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            border: 2px solid #e0e0e0;
        }
        
        .charge-ball {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            font-weight: 700;
            color: white;
            cursor: move;
            transition: box-shadow 0.3s ease;
            z-index: 10;
            user-select: none;
        }
        
        .charge-ball.positive {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ee5a24);
            box-shadow: 0 0 30px rgba(255, 107, 107, 0.6);
        }
        
        .charge-ball.negative {
            background: radial-gradient(circle at 30% 30%, #4ecdc4, #44a3aa);
            box-shadow: 0 0 30px rgba(78, 205, 196, 0.6);
        }
        
        .charge-ball:hover {
            transform: scale(1.05);
        }
        
        .charge-ball.dragging {
            transform: scale(1.1);
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.3);
        }
        
        .force-vector {
            position: absolute;
            height: 6px;
            background: linear-gradient(90deg, #feca57, #ff9ff3);
            transform-origin: left center;
            transition: all 0.3s ease;
            z-index: 5;
        }
        
        .force-vector::after {
            content: '';
            position: absolute;
            right: -15px;
            top: -10px;
            width: 0;
            height: 0;
            border-left: 25px solid #ff9ff3;
            border-top: 12px solid transparent;
            border-bottom: 12px solid transparent;
        }
        
        .force-vector.attraction {
            background: linear-gradient(90deg, #4ecdc4, #44a3aa);
        }
        
        .force-vector.attraction::after {
            border-left-color: #44a3aa;
        }
        
        .distance-line {
            position: absolute;
            height: 2px;
            background: #ddd;
            border-top: 2px dashed #999;
            z-index: 1;
        }
        
        .distance-label {
            position: absolute;
            background: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 15;
        }
        
        .controls-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
        }
        
        .control-group {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 3px 15px rgba(0, 0, 0, 0.08);
        }
        
        .control-label {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: white;
        }
        
        .control-icon.positive {
            background: #ff6b6b;
        }
        
        .control-icon.negative {
            background: #4ecdc4;
        }
        
        .control-icon.distance {
            background: #667eea;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }
        
        .slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #e0e0e0;
            border-radius: 5px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
        }
        
        .slider-value {
            min-width: 80px;
            padding: 8px 12px;
            background: #f0f3ff;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-weight: 600;
            color: #667eea;
            text-align: center;
            font-size: 14px;
        }
        
        .result-display {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }
        
        .result-label {
            font-size: 16px;
            opacity: 0.9;
            margin-bottom: 10px;
        }
        
        .result-value {
            font-size: 36px;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .result-unit {
            font-size: 18px;
            opacity: 0.8;
            margin-left: 5px;
        }
        
        .success-message {
            background: linear-gradient(135deg, #4caf50, #45a049);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin-top: 20px;
            font-size: 18px;
            font-weight: 500;
        }
        
        .controls-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        .control-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 12px 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .control-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .control-btn.next-btn {
            background: linear-gradient(135deg, #4caf50, #45a049);
        }
        
        .control-btn.next-btn:hover {
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }
        
        /* Potential Maze Styles */
        .maze-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .maze-visualization {
            height: 500px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            border: 2px solid #e0e0e0;
        }
        
        .maze-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(10, 1fr);
            gap: 1px;
        }
        
        .maze-cell {
            background: white;
            position: relative;
        }
        
        .maze-cell.wall {
            background: #333;
        }
        
        .maze-cell.start {
            background: #4ecdc4;
        }
        
        .maze-cell.end {
            background: #ff6b6b;
        }
        
        .player {
            position: absolute;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle at 30% 30%, #feca57, #ff9ff3);
            border-radius: 50%;
            transition: all 0.2s ease;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 700;
            color: white;
        }
        
        .maze-charge {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: 700;
            color: white;
            cursor: move;
            transition: box-shadow 0.3s ease;
            z-index: 15;
            user-select: none;
        }
        
        .maze-charge.positive {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ee5a24);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }
        
        .maze-charge.negative {
            background: radial-gradient(circle at 30% 30%, #4ecdc4, #44a3aa);
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }
        
        .maze-charge:hover {
            transform: scale(1.1);
        }
        
        .maze-charge.dragging {
            transform: scale(1.2);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.3);
        }
        
        .potential-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            z-index: 20;
        }
        
        .potential-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .potential-value {
            font-size: 24px;
            font-weight: 700;
            color: #667eea;
        }
        
        /* Gauss Challenge Styles */
        .gauss-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .gauss-visualization {
            height: 500px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            border: 2px solid #e0e0e0;
        }
        
        .gauss-charge {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: 700;
            color: white;
            z-index: 5;
            user-select: none;
        }
        
        .gauss-charge.positive {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ee5a24);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }
        
        .gauss-charge.negative {
            background: radial-gradient(circle at 30% 30%, #4ecdc4, #44a3aa);
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }
        
        .gaussian-surface {
            position: absolute;
            border: 3px dashed #667eea;
            border-radius: 50%;
            pointer-events: none;
            background: rgba(102, 126, 234, 0.1);
            cursor: move;
            z-index: 10;
        }
        
        .gaussian-surface.dragging {
            border-color: #ff9ff3;
            background: rgba(255, 159, 243, 0.1);
        }
        
        .flux-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            z-index: 20;
        }
        
        .flux-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .flux-value {
            font-size: 24px;
            font-weight: 700;
            color: #667eea;
        }
        
        .enclosed-value {
            font-size: 20px;
            font-weight: 600;
            color: #764ba2;
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            .game-header {
                padding: 20px;
            }
            
            .game-title {
                font-size: 24px;
            }
            
            .language-selector {
                position: static;
                margin-top: 15px;
                text-align: center;
                justify-content: center;
            }
            
            .game-content {
                padding: 20px;
            }
            
            .level-card {
                min-width: 150px;
            }
            
            .controls-panel {
                grid-template-columns: 1fr;
            }
            
            .charge-ball {
                width: 60px;
                height: 60px;
                font-size: 28px;
            }
            
            .force-visualization {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Translations for different languages
        const translations = {
            eng: {
                title: "Physics Adventure",
                subtitle: "Electric Charges and Fields - Grade 12",
                levels: [
                    { name: "Field Visualizer", desc: "Create electric fields", icon: "⚡" },
                    { name: "Coulomb's Lab", desc: "Experiment with forces", icon: "🔬" },
                    { name: "Gauss Challenge", desc: "Master flux calculation", icon: "🌀" },
                    { name: "Potential Maze", desc: "Navigate by potential", icon: "🎯" }
                ],
                fieldVisualizer: {
                    title: "Electric Field Visualizer",
                    instruction: "Place charges to create electric fields. Try different configurations!",
                    positive: "Add Positive",
                    negative: "Add Negative",
                    clear: "Clear All",
                    charges: "Charges",
                    success: "Great! You've created an electric field!",
                    reset: "Reset Field"
                },
                coulombsLab: {
                    title: "Coulomb's Law Laboratory",
                    instruction: "Drag the charges to see how the force changes. Experiment with different configurations!",
                    charge1: "Charge 1",
                    charge2: "Charge 2",
                    distance: "Distance",
                    force: "Force",
                    success: "Excellent! You've experimented with Coulomb's Law!",
                    reset: "Reset Experiment"
                },
                potentialMaze: {
                    title: "Electric Potential Maze",
                    instruction: "Navigate the maze and move charges to explore electric potential!",
                    potential: "Current Potential",
                    success: "Congratulations! You've explored the potential maze!",
                    reset: "Reset Maze"
                },
                gaussChallenge: {
                    title: "Gauss's Law Challenge",
                    instruction: "Move the Gaussian surface to explore electric flux!",
                    flux: "Electric Flux",
                    enclosed: "Enclosed Charge",
                    success: "Excellent! You've explored Gauss's Law!",
                    reset: "Reset Challenge"
                },
                controls: {
                    play: "Play",
                    pause: "Pause",
                    replay: "Replay",
                    next: "Next"
                }
            },
            tam: {
                title: "இயற்பியல் சாகசம்",
                subtitle: "மின் சுமைகள் மற்றும் மின் புலங்கள் - 12 ஆம் வகுப்பு",
                levels: [
                    { name: "புலக் காட்சியகம்", desc: "மின் புலங்களை உருவாக்குங்கள்", icon: "⚡" },
                    { name: "கூலோம்பின் ஆய்வகம்", desc: "விசைகளுடன் பரிசோதிக்கவும்", icon: "🔬" },
                    { name: "காஸ் சவால்", desc: "பாய்வு கணக்கீட்டை முடிக்கவும்", icon: "🌀" },
                    { name: "திறன் சிக்கலான பாதை", desc: "சம திறன் கோடுகளைப் பின்பற்றவும்", icon: "🎯" }
                ],
                fieldVisualizer: {
                    title: "மின் புலக் காட்சியகம்",
                    instruction: "மின் புலங்களை உருவாக்க சுமைகளை வைக்கவும். வெவ்வேறு கட்டமைப்புகளை முயற்சிக்கவும்!",
                    positive: "நேர்மறையைச் சேர்",
                    negative: "எதிர்மறையைச் சேர்",
                    clear: "அனைத்தையும் அழி",
                    charges: "சுமைகள்",
                    success: "அற்புதம்! நீங்கள் ஒரு மின் புலத்தை உருவாக்கியுள்ளீர்கள்!",
                    reset: "புலத்தை மீட்டமை"
                },
                coulombsLab: {
                    title: "கூலோம்பின் சட்டம் ஆய்வகம்",
                    instruction: "விசை எவ்வாறு மாறுகிறது என்பதைக் காண சுமைகளை இழுத்துப் போடுங்கள். வெவ்வேறு கட்டமைப்புகளை முயற்சிக்கவும்!",
                    charge1: "சுமை 1",
                    charge2: "சுமை 2",
                    distance: "தூரம்",
                    force: "விசை",
                    success: "சிறப்பு! நீங்கள் கூலோம்பின் சட்டத்தை சிறப்பாக கற்றுக்கொண்டீர்கள்!",
                    reset: "பரிசோதனையை மீட்டமை"
                },
                potentialMaze: {
                    title: "மின் திறன் சிக்கலான பாதை",
                    instruction: "சிக்கலான பாதையைத் தாண்டி சுமைகளை நகர்த்தி மின் திறனை ஆராயுங்கள்!",
                    potential: "தற்போதைய திறன்",
                    success: "வாழ்த்துக்கள்! நீங்கள் சிக்கலான பாதையை ஆராய்ந்துள்ளீர்கள்!",
                    reset: "சிக்கலான பாதையை மீட்டமை"
                },
                gaussChallenge: {
                    title: "காஸ் சட்டம் சவால்",
                    instruction: "காஸியன் மேற்பரப்பை நகர்த்தி மின் பாய்வை ஆராயுங்கள்!",
                    flux: "மின் பாய்வு",
                    enclosed: "மூடப்பட்ட சுமை",
                    success: "அருமை! நீங்கள் காஸ் சட்டத்தை சரியாகப் பயன்படுத்தியுள்ளீர்கள்!",
                    reset: "சவாலை மீட்டமை"
                },
                controls: {
                    play: "விளையாடு",
                    pause: "இடைநிறுத்து",
                    replay: "மீண்டும் விளையாடு",
                    next: "அடுத்தது"
                }
            },
            tel: {
                title: "భౌతిక శాస్త్రం సాహస యాత్ర",
                subtitle: "ఎలక్ట్రిక్ ఛార్జీలు మరియు ఫీల్డ్స్ - 12వ తరగతి",
                levels: [
                    { name: "ఫీల్డ్ విజువలైజర్", desc: "ఎలక్ట్రిక్ ఫీల్డ్స్ సృష్టించండి", icon: "⚡" },
                    { name: "కౌలమ్బ్ ల్యాబ్", desc: "ఫోర్సెస్‌తో ప్రయోగం చేయండి", icon: "🔬" },
                    { name: "గాస్ ఛాలెంజ్", desc: "ఫ్లక్స్ లెక్కింపు మాస్టర్ చేయండి", icon: "🌀" },
                    { name: "పొటెన్షియల్ మేజ్", desc: "పొటెన్షియల్ ద్వారా నావిగేట్ చేయండి", icon: "🎯" }
                ],
                fieldVisualizer: {
                    title: "ఎలక్ట్రిక్ ఫీల్డ్ విజువలైజర్",
                    instruction: "ఎలక్ట్రిక్ ఫీల్డ్స్ సృష్టించడానికి ఛార్జీలను ఉంచండి. వివిధ ఆకృతీకరణలను ప్రయత్నించండి!",
                    positive: "పాజిటివ్ జోడించు",
                    negative: "నెగిటివ్ జోడించు",
                    clear: "అన్నింటినీ తీసివేయి",
                    charges: "ఛార్జీలు",
                    success: "గొప్ప! మీరు ఎలక్ట్రిక్ ఫీల్డ్‌ను సృష్టించారు!",
                    reset: "ఫీల్డ్‌ను రీసెట్ చేయండి"
                },
                coulombsLab: {
                    title: "కౌలమ్బ్ లా ల్యాబొరేటరీ",
                    instruction: "ఫోర్స్ ఎలా మారుతుందో చూడటానికి ఛార్జీలను లాగి పెట్టండి. వివిధ ఆకృతీకరణలను ప్రయత్నించండి!",
                    charge1: "ఛార్జ్ 1",
                    charge2: "ఛార్జ్ 2",
                    distance: "దూరం",
                    force: "ఫోర్స్",
                    success: "అద్భుతం! మీరు కౌలమ్బ్ లాను మాస్టర్ చేశారు!",
                    reset: "ప్రయోగాన్ని రీసెట్ చేయండి"
                },
                potentialMaze: {
                    title: "ఎలక్ట్రిక్ పొటెన్షియల్ మేజ్",
                    instruction: "మేజ్‌ను నావిగేట్ చేయండి మరియు ఛార్జీలను తరలించి ఎలక్ట్రిక్ పొటెన్షియల్‌ను అన్వేషించండి!",
                    potential: "ప్రస్తుత పొటెన్షియల్",
                    success: "అభినందనలు! మీరు మేజ్‌ను అన్వేషించారు!",
                    reset: "మేజ్‌ను రీసెట్ చేయండి"
                },
                gaussChallenge: {
                    title: "గాస్ లా ఛాలెంజ్",
                    instruction: "గాసియన్ ఉపరితలాన్ని కదిపించి ఎలక్ట్రిక్ ఫ్లక్స్‌ను అన్వేషించండి!",
                    flux: "ఎలక్ట్రిక్ ఫ్లక్స్",
                    enclosed: "మూసిన ఛార్జ్",
                    success: "గొప్ప! మీరు గాస్ లాను సరైనంగా వర్తించారు!",
                    reset: "ఛాలెంజ్‌ను రీసెట్ చేయండి"
                },
                controls: {
                    play: "ఆడండి",
                    pause: "విరామం",
                    replay: "మళ్ళీ ఆడండి",
                    next: "తదుపరి"
                }
            },
            hin: {
                title: "भौतिकी साहसिक यात्रा",
                subtitle: "विद्युत आवेश और क्षेत्र - 12वीं कक्षा",
                levels: [
                    { name: "क्षेत्र दृश्यक", desc: "विद्युत क्षेत्र बनाएं", icon: "⚡" },
                    { name: "कूलॉम्ब प्रयोगशाला", desc: "बलों के साथ प्रयोग करें", icon: "🔬" },
                    { name: "गॉस चुनौती", desc: "प्रवाह गणना में महारत हों", icon: "🌀" },
                    { name: "विभव मार्ग", desc: "विभव रेखाओं से नेविगेट करें", icon: "🎯" }
                ],
                fieldVisualizer: {
                    title: "विद्युत क्षेत्र दृश्यक",
                    instruction: "विद्युत क्षेत्र बनाने के लिए आवेश रखें। विभिन्न विन्यास आज़माएं!",
                    positive: "धनात्मक जोड़ें",
                    negative: "ऋणात्मक जोड़ें",
                    clear: "सभी साफ़ करें",
                    charges: "आवेश",
                    success: "बढ़िया! आपने एक विद्युत क्षेत्र बनाया है!",
                    reset: "क्षेत्र रीसेट करें"
                },
                coulombsLab: {
                    title: "कूलॉम्ब का नियम प्रयोगशाला",
                    instruction: "बल कैसे बदलता है देखने के लिए आवेश खींचें। विभिन्न विन्यास आज़माएं!",
                    charge1: "आवेश 1",
                    charge2: "आवेश 2",
                    distance: "दूरी",
                    force: "बल",
                    success: "बढ़िया! आपने कूलॉम्ब का नियम सीख लिया!",
                    reset: "प्रयोग रीसेट करें"
                },
                potentialMaze: {
                    title: "विद्युत विभव मार्ग",
                    instruction: "मार्ग नेविगेट करें और आवेश खींचकर विद्युत विभव का अन्वेषण करें!",
                    potential: "वर्तमान विभव",
                    success: "बधाई हो! आपने विभव मार्ग का अन्वेषण किया!",
                    reset: "मार्ग रीसेट करें"
                },
                gaussChallenge: {
                    title: "गॉस का नियम चुनौती",
                    instruction: "गाउसीयन सतह खींचें और विद्युत प्रवाह का अन्वेषण करें!",
                    flux: "विद्युत प्रवाह",
                    enclosed: "घिरा हुआ आवेश",
                    success: "शानदार! आपने गॉस का नियम सही ढंग से लागू किया!",
                    reset: "चुनौती रीसेट करें"
                },
                controls: {
                    play: "खेलें",
                    pause: "रोकें",
                    replay: "फिर से खेलें",
                    next: "अगला"
                }
            },
            ori: {
                title: "ଭୌତିକ ବିଜ୍ଞାନ ଅଭିଯାନ",
                subtitle: "ବିଦ୍ୟୁତ୍ ଆବେଶ ଏବଂ କ୍ଷେତ୍ର - ୧୨ମ ଶ୍ରେଣୀ",
                levels: [
                    { name: "କ୍ଷେତ୍ର ଦୃଶ୍ୟକାରୀ", desc: "ବିଦ୍ୟୁତ୍ କ୍ଷେତ୍ର ସୃଷ୍ଟି କରନ୍ତୁ", icon: "⚡" },
                    { name: "କୁଲମ୍ ପରୀକ୍ଷାଗାର", desc: "ଶକ୍ତି ସହିତ ପରୀକ୍ଷା କରନ୍ତୁ", icon: "🔬" },
                    { name: "ଗାଉସ୍ ଚ୍ୟାଲେଞ୍ଜ୍", desc: "ପ୍ରବାହ ଗଣନାରେ ମାସ୍ଟର୍ ହୁଅନ୍ତୁ", icon: "🌀" },
                    { name: "ବିଭବ ମାର୍ଗ", desc: "ବିଭବ ରେଖା ଅନୁସାରେ ଚାଲନ୍ତୁ", icon: "🎯" }
                ],
                fieldVisualizer: {
                    title: "ବିଦ୍ୟୁତ୍ କ୍ଷେତ୍ର ଦୃଶ୍ୟକାରୀ",
                    instruction: "ବିଦ୍ୟୁତ୍ କ୍ଷେତ୍ର ସୃଷ୍ଟି କରିବାକୁ ଆବେଶ ରଖନ୍ତୁ। ବିଭିନ୍ନ ବିନ୍ୟାସ ଚେଷ୍ଟା କରନ୍ତୁ!",
                    positive: "ଯୋଗାତ୍ମକ ଯୋଡ଼ନ୍ତୁ",
                    negative: "ଋଣାତ୍ମକ ଯୋଡ଼ନ୍ତୁ",
                    clear: "ସବୁ ସଫା କରନ୍ତୁ",
                    charges: "ଆବେଶ",
                    success: "ଅଦ୍ଭୁତ! ଆପଣ ଏକ ବିଦ୍ୟୁତ୍ କ୍ଷେତ୍ର ସୃଷ୍ଟି କରିଛନ୍ତି!",
                    reset: "କ୍ଷେତ୍ର ପୁନଃସ୍ଥାପନ କରନ୍ତୁ"
                },
                coulombsLab: {
                    title: "କୁଲମ୍ ନିୟମ ପରୀକ୍ଷାଗାର",
                    instruction: "ଶକ୍ତି କିପରି ପରିବର୍ତ୍ତନ ହୁଏ ଦେଖିବାକୁ ଆବେଶ ଟାଣି ଆଣନ୍ତୁ। ବିଭିନ୍ନ ବିନ୍ୟାସ ଚେଷ୍ଟା କରନ୍ତୁ!",
                    charge1: "ଆବେଶ ୧",
                    charge2: "ଆବେଶ ୨",
                    distance: "ଦୂରତା",
                    force: "ଶକ୍ତି",
                    success: "ଅଦ୍ଭୁତ! ଆପଣ କୁଲମ୍ ନିୟମ ଶିଖିଛନ୍ତି!",
                    reset: "ପରୀକ୍ଷା ପୁନଃସ୍ଥାପନ କରନ୍ତୁ"
                },
                potentialMaze: {
                    title: "ବିଦ୍ୟୁତ୍ ବିଭବ ମାର୍ଗ",
                    instruction: "ମାର୍ଗ ଚାଲନ୍ତୁ ଏବଂ ଆବେଶ ଟାଣି ବିଦ୍ୟୁତ୍ ବିଭବକୁ ଅନ୍ୱେଷଣ କରନ୍ତୁ!",
                    potential: "ବର୍ତ୍ତମାନ ବିଭବ",
                    success: "ଅଭିନନ୍ଦନ! ଆପଣ ବିଭବ ମାର୍ଗକୁ ଅନ୍ୱେଷଣ କରିଛନ୍ତି!",
                    reset: "ମାର୍ଗ ପୁନଃସ୍ଥାପନ କରନ୍ତୁ"
                },
                gaussChallenge: {
                    title: "ଗାଉସ୍ ନିୟମ ଚ୍ୟାଲେଞ୍ଜ୍",
                    instruction: "ଗାଉସିଆନ୍ ପୃଷ୍ଠକୁ ଟାଣି ଏବଂ ବିଦ୍ୟୁତ୍ ପ୍ରବାହକୁ ଅନ୍ୱେଷଣ କରନ୍ତୁ!",
                    flux: "ବିଦ୍ୟୁତ୍ ପ୍ରବାହ",
                    enclosed: "ବେଢ଼ା ଆବେଶ",
                    success: "ବଢ଼ିଆ! ଆପଣ ଗାଉସ୍ ନିୟମ ସଠିକ୍ ଭାବରେ ପ୍ରୟୋଗ କରିଛନ୍ତି!",
                    reset: "ଚ୍ୟାଲେଞ୍ଜ୍ ପୁନଃସ୍ଥାପନ କରନ୍ତୁ"
                },
                controls: {
                    play: "ଖେଳନ୍ତୁ",
                    pause: "ବିରାମ",
                    replay: "ପୁନର୍ବାର ଖେଳନ୍ତୁ",
                    next: "ପରବର୍ତ୍ତୀ"
                }
            }
        };

        // Field Visualizer Component
        const FieldVisualizer = ({ translation, onComplete }) => {
            const [charges, setCharges] = useState([]);
            const [fieldLines, setFieldLines] = useState([]);
            const [forceVectors, setForceVectors] = useState([]);
            const [dragging, setDragging] = useState(null);
            const [showSuccess, setShowSuccess] = useState(false);
            const canvasRef = useRef(null);
            
            // Add a new charge to the canvas
            const addCharge = (type) => {
                if (!canvasRef.current) return;
                
                const rect = canvasRef.current.getBoundingClientRect();
                const x = rect.width / 2;
                const y = rect.height / 2;
                
                const newCharge = {
                    id: Date.now(),
                    x,
                    y,
                    value: type === 'positive' ? 5 : -5
                };
                
                setCharges(prev => [...prev, newCharge]);
                
                // Show success after adding first charge
                if (charges.length === 0) {
                    setShowSuccess(true);
                    onComplete();
                }
            };
            
            // Clear all charges
            const clearCharges = () => {
                setCharges([]);
                setFieldLines([]);
                setForceVectors([]);
                setShowSuccess(false);
            };
            
            // Calculate and draw field lines
            useEffect(() => {
                if (charges.length === 0) {
                    setFieldLines([]);
                    setForceVectors([]);
                    return;
                }
                
                const newFieldLines = [];
                const numLines = 8; // Number of field lines per charge
                
                charges.forEach(charge => {
                    for (let i = 0; i < numLines; i++) {
                        const angle = (i / numLines) * 2 * Math.PI;
                        const startRadius = 30; // Starting radius from charge
                        
                        const startX = charge.x + startRadius * Math.cos(angle);
                        const startY = charge.y + startRadius * Math.sin(angle);
                        
                        // Create a field line with multiple points
                        const linePoints = [{ x: startX, y: startY }];
                        let currentX = startX;
                        let currentY = startY;
                        
                        // Trace the field line
                        for (let step = 0; step < 50; step++) {
                            let Ex = 0;
                            let Ey = 0;
                            
                            // Calculate electric field at current point
                            charges.forEach(c => {
                                const dx = currentX - c.x;
                                const dy = currentY - c.y;
                                const rSquared = dx * dx + dy * dy;
                                
                                if (rSquared > 1) { // Avoid division by zero
                                    const r = Math.sqrt(rSquared);
                                    const E = c.value / rSquared;
                                    
                                    Ex += E * dx / r;
                                    Ey += E * dy / r;
                                }
                            });
                            
                            // Normalize and scale
                            const E = Math.sqrt(Ex * Ex + Ey * Ey);
                            if (E > 0) {
                                const stepSize = 10;
                                currentX += stepSize * Ex / E;
                                currentY += stepSize * Ey / E;
                                
                                // Check if point is within canvas
                                if (canvasRef.current) {
                                    const rect = canvasRef.current.getBoundingClientRect();
                                    if (currentX < 0 || currentX > rect.width || 
                                        currentY < 0 || currentY > rect.height) {
                                        break;
                                    }
                                }
                                
                                linePoints.push({ x: currentX, y: currentY });
                            } else {
                                break;
                            }
                        }
                        
                        if (linePoints.length > 1) {
                            newFieldLines.push({
                                id: `${charge.id}-${i}`,
                                points: linePoints,
                                chargeType: charge.value > 0 ? 'positive' : 'negative'
                            });
                        }
                    }
                });
                
                setFieldLines(newFieldLines);
                
                // Calculate force vectors between charges
                const newForceVectors = [];
                const k = 8.99e9; // Coulomb's constant
                
                for (let i = 0; i < charges.length; i++) {
                    for (let j = i + 1; j < charges.length; j++) {
                        const charge1 = charges[i];
                        const charge2 = charges[j];
                        
                        const dx = charge2.x - charge1.x;
                        const dy = charge2.y - charge1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            // Calculate force magnitude (scaled for visualization)
                            const forceMagnitude = Math.abs(k * charge1.value * charge2.value / (distance * distance)) * 1e-6;
                            const maxVectorLength = 100; // Maximum vector length for visualization
                            const vectorLength = Math.min(forceMagnitude * 10, maxVectorLength);
                            
                            const angle = Math.atan2(dy, dx);
                            const isAttraction = charge1.value * charge2.value < 0;
                            
                            // Vector from charge1 to charge2
                            newForceVectors.push({
                                id: `${charge1.id}-${charge2.id}`,
                                startX: charge1.x,
                                startY: charge1.y,
                                length: vectorLength,
                                angle: angle,
                                type: isAttraction ? 'attraction' : 'repulsion'
                            });
                            
                            // Vector from charge2 to charge1
                            newForceVectors.push({
                                id: `${charge2.id}-${charge1.id}`,
                                startX: charge2.x,
                                startY: charge2.y,
                                length: vectorLength,
                                angle: angle + Math.PI,
                                type: isAttraction ? 'attraction' : 'repulsion'
                            });
                        }
                    }
                }
                
                setForceVectors(newForceVectors);
            }, [charges]);
            
            const handleMouseDown = (e, chargeId) => {
                e.preventDefault();
                setDragging(chargeId);
            };
            
            const handleMouseMove = (e) => {
                if (!dragging || !canvasRef.current) return;
                
                const rect = canvasRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Keep charges within bounds
                const boundedX = Math.max(25, Math.min(rect.width - 25, x));
                const boundedY = Math.max(25, Math.min(rect.height - 25, y));
                
                setCharges(prev => prev.map(charge => 
                    charge.id === dragging 
                        ? { ...charge, x: boundedX, y: boundedY } 
                        : charge
                ));
            };
            
            const handleMouseUp = () => {
                setDragging(null);
            };
            
            const resetField = () => {
                setCharges([]);
                setFieldLines([]);
                setForceVectors([]);
                setShowSuccess(false);
            };
            
            return (
                <div className="puzzle-container">
                    <h3 className="puzzle-title">{translation.fieldVisualizer.title}</h3>
                    <p style={{ textAlign: 'center', marginBottom: '20px' }}>
                        {translation.fieldVisualizer.instruction}
                    </p>
                    
                    <div className="field-visualizer-container">
                        <div 
                            ref={canvasRef}
                            className="field-canvas"
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                        >
                            {/* Field lines */}
                            {fieldLines.map(line => (
                                <React.Fragment key={line.id}>
                                    {line.points.slice(0, -1).map((point, index) => {
                                        const nextPoint = line.points[index + 1];
                                        const dx = nextPoint.x - point.x;
                                        const dy = nextPoint.y - point.y;
                                        const length = Math.sqrt(dx * dx + dy * dy);
                                        const angle = Math.atan2(dy, dx);
                                        
                                        return (
                                            <React.Fragment key={`${line.id}-${index}`}>
                                                <div
                                                    className="field-line"
                                                    style={{
                                                        left: point.x,
                                                        top: point.y,
                                                        width: length,
                                                        transform: `rotate(${angle}rad)`,
                                                        transformOrigin: '0 50%',
                                                        background: line.chargeType === 'positive' 
                                                            ? 'linear-gradient(90deg, rgba(255, 107, 107, 0.7), rgba(238, 90, 36, 0.7))'
                                                            : 'linear-gradient(90deg, rgba(78, 205, 196, 0.7), rgba(68, 163, 170, 0.7))'
                                                    }}
                                                />
                                                <div
                                                    className="field-arrow"
                                                    style={{
                                                        left: nextPoint.x - 8,
                                                        top: nextPoint.y - 5,
                                                        borderLeftColor: line.chargeType === 'positive' 
                                                            ? 'rgba(238, 90, 36, 0.7)'
                                                            : 'rgba(68, 163, 170, 0.7)'
                                                    }}
                                                />
                                            </React.Fragment>
                                        );
                                    })}
                                </React.Fragment>
                            ))}
                            
                            {/* Force vectors */}
                            {forceVectors.map(vector => (
                                <div
                                    key={vector.id}
                                    className={`force-vector ${vector.type}`}
                                    style={{
                                        left: vector.startX,
                                        top: vector.startY,
                                        width: vector.length,
                                        transform: `rotate(${vector.angle}rad)`,
                                        transformOrigin: '0 50%'
                                    }}
                                />
                            ))}
                            
                            {/* Charges */}
                            {charges.map(charge => (
                                <div
                                    key={charge.id}
                                    className={`field-charge ${charge.value > 0 ? 'positive' : 'negative'} ${dragging === charge.id ? 'dragging' : ''}`}
                                    style={{
                                        left: charge.x - 25,
                                        top: charge.y - 25
                                    }}
                                    onMouseDown={(e) => handleMouseDown(e, charge.id)}
                                >
                                    {charge.value > 0 ? '+' : '-'}{Math.abs(charge.value)}
                                </div>
                            ))}
                            
                            {/* Charge info */}
                            <div className="field-info" style={{ position: 'absolute', top: '20px', left: '20px' }}>
                                <div className="field-info-label">{translation.fieldVisualizer.charges}</div>
                                <div className="field-info-value">{charges.length}</div>
                            </div>
                        </div>
                        
                        <div className="field-controls">
                            <button className="field-btn" onClick={() => addCharge('positive')}>
                                <span>+</span> {translation.fieldVisualizer.positive}
                            </button>
                            <button className="field-btn" onClick={() => addCharge('negative')}>
                                <span>-</span> {translation.fieldVisualizer.negative}
                            </button>
                            <button className="field-btn" onClick={clearCharges}>
                                {translation.fieldVisualizer.clear}
                            </button>
                        </div>
                    </div>
                    
                    {showSuccess && (
                        <div className="success-message">
                            {translation.fieldVisualizer.success}
                        </div>
                    )}
                    
                    <div className="controls-container">
                        <button className="control-btn" onClick={resetField}>
                            {translation.fieldVisualizer.reset}
                        </button>
                    </div>
                </div>
            );
        };

        const CoulombsLab = ({ translation, onComplete }) => {
            const [charge1, setCharge1] = useState({ x: 150, y: 200, value: 5 });
            const [charge2, setCharge2] = useState({ x: 450, y: 200, value: -3 });
            const [dragging, setDragging] = useState(null);
            const [showSuccess, setShowSuccess] = useState(false);
            const [hasInteracted, setHasInteracted] = useState(false);
            const visualizationRef = useRef(null);
            
            // Calculate distance between charges
            const distance = Math.sqrt(
                Math.pow(charge2.x - charge1.x, 2) + 
                Math.pow(charge2.y - charge1.y, 2)
            );
            
            // Calculate force using Coulomb's law (simplified for visualization)
            const k = 8.99e9; // Coulomb's constant
            const force = Math.abs(k * Math.abs(charge1.value * charge2.value) / Math.pow(distance / 100, 2)) * 1e-6;
            
            const handleMouseDown = (e, chargeId) => {
                e.preventDefault();
                setDragging(chargeId);
            };
            
            const handleMouseMove = (e) => {
                if (!dragging || !visualizationRef.current) return;
                
                const rect = visualizationRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Keep charges within bounds
                const boundedX = Math.max(40, Math.min(rect.width - 40, x));
                const boundedY = Math.max(40, Math.min(rect.height - 40, y));
                
                if (dragging === 'charge1') {
                    setCharge1(prev => ({ ...prev, x: boundedX, y: boundedY }));
                } else if (dragging === 'charge2') {
                    setCharge2(prev => ({ ...prev, x: boundedX, y: boundedY }));
                }
            };
            
            const handleMouseUp = () => {
                if (dragging && !hasInteracted) {
                    setHasInteracted(true);
                    setShowSuccess(true);
                    onComplete();
                }
                setDragging(null);
            };
            
            const resetExperiment = () => {
                setCharge1({ x: 150, y: 200, value: 5 });
                setCharge2({ x: 450, y: 200, value: -3 });
                setShowSuccess(false);
                setHasInteracted(false);
            };
            
            // Calculate force vector properties
            const forceDirection = charge1.value * charge2.value > 0 ? 'repulsion' : 'attraction';
            const forceAngle = Math.atan2(charge2.y - charge1.y, charge2.x - charge1.x);
            const forceLength = Math.min(distance * 0.4, 150); // Scale force vector for visualization
            
            return (
                <div className="puzzle-container">
                    <h3 className="puzzle-title">{translation.coulombsLab.title}</h3>
                    <p style={{ textAlign: 'center', marginBottom: '20px' }}>
                        {translation.coulombsLab.instruction}
                    </p>
                    
                    <div className="coulombs-lab-container">
                        <div 
                            ref={visualizationRef}
                            className="force-visualization"
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                        >
                            {/* Distance line */}
                            <div 
                                className="distance-line"
                                style={{
                                    left: charge1.x,
                                    top: charge1.y,
                                    width: distance,
                                    transform: `rotate(${forceAngle}rad)`,
                                    transformOrigin: '0 50%'
                                }}
                            />
                            
                            {/* Distance label */}
                            <div 
                                className="distance-label"
                                style={{
                                    left: (charge1.x + charge2.x) / 2 - 30,
                                    top: (charge1.y + charge2.y) / 2 - 30
                                }}
                            >
                                {distance.toFixed(0)} mm
                            </div>
                            
                            {/* Force vectors */}
                            <div 
                                className={`force-vector ${forceDirection}`}
                                style={{
                                    left: charge1.x + 40,
                                    top: charge1.y,
                                    width: forceLength,
                                    transform: `rotate(${forceAngle}rad)`,
                                    transformOrigin: '0 50%'
                                }}
                            />
                            
                            <div 
                                className={`force-vector ${forceDirection}`}
                                style={{
                                    left: charge2.x - 40 - forceLength,
                                    top: charge2.y,
                                    width: forceLength,
                                    transform: `rotate(${forceAngle + Math.PI}rad)`,
                                    transformOrigin: '0 50%'
                                }}
                            />
                            
                            {/* Charge 1 */}
                            <div
                                className={`charge-ball positive ${dragging === 'charge1' ? 'dragging' : ''}`}
                                style={{
                                    left: charge1.x - 40,
                                    top: charge1.y - 40
                                }}
                                onMouseDown={(e) => handleMouseDown(e, 'charge1')}
                            >
                                +{Math.abs(charge1.value)}
                            </div>
                            
                            {/* Charge 2 */}
                            <div
                                className={`charge-ball negative ${dragging === 'charge2' ? 'dragging' : ''}`}
                                style={{
                                    left: charge2.x - 40,
                                    top: charge2.y - 40
                                }}
                                onMouseDown={(e) => handleMouseDown(e, 'charge2')}
                            >
                                -{Math.abs(charge2.value)}
                            </div>
                        </div>
                        
                        <div className="controls-panel">
                            <div className="control-group">
                                <label className="control-label">
                                    <span className="control-icon positive">+</span>
                                    {translation.coulombsLab.charge1}
                                </label>
                                <div className="slider-container">
                                    <input
                                        type="range"
                                        className="slider"
                                        min="1"
                                        max="10"
                                        value={Math.abs(charge1.value)}
                                        onChange={(e) => {
                                            setCharge1(prev => ({ 
                                                ...prev, 
                                                value: prev.value > 0 ? parseInt(e.target.value) : -parseInt(e.target.value)
                                            }));
                                            if (!hasInteracted) {
                                                setHasInteracted(true);
                                                setShowSuccess(true);
                                                onComplete();
                                            }
                                        }}
                                    />
                                    <div className="slider-value">{Math.abs(charge1.value)} μC</div>
                                </div>
                            </div>
                            
                            <div className="control-group">
                                <label className="control-label">
                                    <span className="control-icon negative">-</span>
                                    {translation.coulombsLab.charge2}
                                </label>
                                <div className="slider-container">
                                    <input
                                        type="range"
                                        className="slider"
                                        min="1"
                                        max="10"
                                        value={Math.abs(charge2.value)}
                                        onChange={(e) => {
                                            setCharge2(prev => ({ 
                                                ...prev, 
                                                value: prev.value > 0 ? parseInt(e.target.value) : -parseInt(e.target.value)
                                            }));
                                            if (!hasInteracted) {
                                                setHasInteracted(true);
                                                setShowSuccess(true);
                                                onComplete();
                                            }
                                        }}
                                    />
                                    <div className="slider-value">{Math.abs(charge2.value)} μC</div>
                                </div>
                            </div>
                            
                            <div className="control-group">
                                <label className="control-label">
                                    <span className="control-icon distance">↔</span>
                                    {translation.coulombsLab.distance}
                                </label>
                                <div className="slider-container">
                                    <div className="slider-value">{distance.toFixed(0)} mm</div>
                                </div>
                            </div>
                            
                            <div className="result-display">
                                <div className="result-label">{translation.coulombsLab.force}</div>
                                <div className="result-value">
                                    {force.toFixed(2)}
                                    <span className="result-unit">N</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    {showSuccess && (
                        <div className="success-message">
                            {translation.coulombsLab.success}
                        </div>
                    )}
                    
                    <div className="controls-container">
                        <button className="control-btn" onClick={resetExperiment}>
                            {translation.coulombsLab.reset}
                        </button>
                    </div>
                </div>
            );
        };

        const PotentialMaze = ({ translation, onComplete }) => {
            const [player, setPlayer] = useState({ x: 30, y: 30 });
            const [charges, setCharges] = useState([
                { id: 1, x: 200, y: 150, value: 5 },
                { id: 2, x: 400, y: 300, value: -3 }
            ]);
            const [dragging, setDragging] = useState(null);
            const [showSuccess, setShowSuccess] = useState(false);
            const [hasInteracted, setHasInteracted] = useState(false);
            const mazeRef = useRef(null);
            
            // Maze layout (1 = wall, 0 = path, 2 = end)
            const maze = [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 0, 1, 1, 1, 0, 1],
                [1, 0, 1, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 0, 1, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
                [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                [1, 0, 1, 0, 0, 0, 1, 0, 2, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ];
            
            // Calculate potential at player position
            const calculatePotential = () => {
                const k = 8.99e9; // Coulomb's constant
                let potential = 0;
                
                charges.forEach(charge => {
                    const dx = player.x - charge.x;
                    const dy = player.y - charge.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 5) { // Avoid division by zero
                        // Scale down for visualization
                        const scale = 1e-9;
                        potential += k * charge.value / distance * scale;
                    }
                });
                
                return potential;
            };
            
            const potential = calculatePotential();
            
            const handleKeyDown = (e) => {
                const step = 10;
                let newX = player.x;
                let newY = player.y;
                
                switch (e.key) {
                    case 'ArrowUp':
                        newY -= step;
                        break;
                    case 'ArrowDown':
                        newY += step;
                        break;
                    case 'ArrowLeft':
                        newX -= step;
                        break;
                    case 'ArrowRight':
                        newX += step;
                        break;
                    default:
                        return;
                }
                
                // Check if new position is valid (not in a wall)
                if (mazeRef.current) {
                    const cellSize = mazeRef.current.offsetWidth / 10;
                    const col = Math.floor(newX / cellSize);
                    const row = Math.floor(newY / cellSize);
                    
                    if (row >= 0 && row < 10 && col >= 0 && col < 10 && maze[row][col] !== 1) {
                        setPlayer({ x: newX, y: newY });
                        
                        // Mark as interacted after moving 5 steps
                        if (!hasInteracted) {
                            const steps = Math.floor(Math.sqrt(Math.pow(newX - 30, 2) + Math.pow(newY - 30, 2)) / step);
                            if (steps >= 5) {
                                setHasInteracted(true);
                                setShowSuccess(true);
                                onComplete();
                            }
                        }
                    }
                }
            };
            
            const handleMouseDown = (e, chargeId) => {
                e.preventDefault();
                setDragging(chargeId);
            };
            
            const handleMouseMove = (e) => {
                if (!dragging || !mazeRef.current) return;
                
                const rect = mazeRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Keep charges within bounds
                const boundedX = Math.max(20, Math.min(rect.width - 20, x));
                const boundedY = Math.max(20, Math.min(rect.height - 20, y));
                
                setCharges(prev => prev.map(charge => 
                    charge.id === dragging 
                        ? { ...charge, x: boundedX, y: boundedY } 
                        : charge
                ));
            };
            
            const handleMouseUp = () => {
                if (dragging && !hasInteracted) {
                    setHasInteracted(true);
                    setShowSuccess(true);
                    onComplete();
                }
                setDragging(null);
            };
            
            const resetMaze = () => {
                setPlayer({ x: 30, y: 30 });
                setCharges([
                    { id: 1, x: 200, y: 150, value: 5 },
                    { id: 2, x: 400, y: 300, value: -3 }
                ]);
                setShowSuccess(false);
                setHasInteracted(false);
            };
            
            useEffect(() => {
                document.addEventListener('keydown', handleKeyDown);
                return () => {
                    document.removeEventListener('keydown', handleKeyDown);
                };
            }, [hasInteracted]);
            
            // Render maze cells
            const renderMaze = () => {
                if (!mazeRef.current) return null;
                
                const cellSize = mazeRef.current.offsetWidth / 10;
                const cells = [];
                
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 10; col++) {
                        const cellType = maze[row][col];
                        let className = 'maze-cell';
                        
                        if (cellType === 1) {
                            className += ' wall';
                        } else if (row === 1 && col === 1) {
                            className += ' start';
                        } else if (cellType === 2) {
                            className += ' end';
                        }
                        
                        cells.push(
                            <div
                                key={`${row}-${col}`}
                                className={className}
                                style={{
                                    position: 'absolute',
                                    left: col * cellSize,
                                    top: row * cellSize,
                                    width: cellSize,
                                    height: cellSize
                                }}
                            />
                        );
                    }
                }
                
                return cells;
            };
            
            return (
                <div className="puzzle-container">
                    <h3 className="puzzle-title">{translation.potentialMaze.title}</h3>
                    <p style={{ textAlign: 'center', marginBottom: '20px' }}>
                        {translation.potentialMaze.instruction}
                    </p>
                    
                    <div className="maze-container">
                        <div 
                            ref={mazeRef}
                            className="maze-visualization"
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                        >
                            <div className="maze-grid">
                                {renderMaze()}
                            </div>
                            
                            {/* Player */}
                            <div
                                className="player"
                                style={{
                                    left: player.x - 15,
                                    top: player.y - 15,
                                    background: potential > 0 
                                        ? 'radial-gradient(circle at 30% 30%, #ff6b6b, #ee5a24)' 
                                        : potential < 0 
                                            ? 'radial-gradient(circle at 30% 30%, #4ecdc4, #44a3aa)'
                                            : 'radial-gradient(circle at 30% 30%, #feca57, #ff9ff3)'
                                }}
                            >
                                P
                            </div>
                            
                            {/* Charges */}
                            {charges.map(charge => (
                                <div
                                    key={charge.id}
                                    className={`maze-charge ${charge.value > 0 ? 'positive' : 'negative'} ${dragging === charge.id ? 'dragging' : ''}`}
                                    style={{
                                        left: charge.x - 20,
                                        top: charge.y - 20
                                    }}
                                    onMouseDown={(e) => handleMouseDown(e, charge.id)}
                                >
                                    {charge.value > 0 ? '+' : '-'}{Math.abs(charge.value)}
                                </div>
                            ))}
                            
                            {/* Potential indicator */}
                            <div className="potential-indicator">
                                <div className="potential-label">{translation.potentialMaze.potential}</div>
                                <div className="potential-value">{potential.toFixed(2)} V</div>
                            </div>
                        </div>
                    </div>
                    
                    {showSuccess && (
                        <div className="success-message">
                            {translation.potentialMaze.success}
                        </div>
                    )}
                    
                    <div className="controls-container">
                        <button className="control-btn" onClick={resetMaze}>
                            {translation.potentialMaze.reset}
                        </button>
                    </div>
                </div>
            );
        };

        const GaussChallenge = ({ translation, onComplete }) => {
            const [charges, setCharges] = useState([
                { id: 1, x: 150, y: 150, value: 5 },
                { id: 2, x: 350, y: 250, value: -3 },
                { id: 3, x: 250, y: 350, value: 2 }
            ]);
            const [gaussianSurface, setGaussianSurface] = useState({ x: 250, y: 250, radius: 100 });
            const [draggingSurface, setDraggingSurface] = useState(false);
            const [showSuccess, setShowSuccess] = useState(false);
            const [hasInteracted, setHasInteracted] = useState(false);
            const gaussRef = useRef(null);
            
            // Calculate enclosed charge and flux
            const calculateEnclosedCharge = () => {
                let enclosedCharge = 0;
                
                charges.forEach(charge => {
                    const dx = charge.x - gaussianSurface.x;
                    const dy = charge.y - gaussianSurface.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < gaussianSurface.radius) {
                        enclosedCharge += charge.value;
                    }
                });
                
                return enclosedCharge;
            };
            
            const enclosedCharge = calculateEnclosedCharge();
            
            // Calculate flux (Gauss's Law: Φ = Q_enclosed / ε₀)
            const epsilon0 = 8.85e-12; // Vacuum permittivity (F/m)
            const flux = enclosedCharge / epsilon0;
            
            const handleMouseDown = (e) => {
                if (!gaussRef.current) return;
                
                const rect = gaussRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const dx = x - gaussianSurface.x;
                const dy = y - gaussianSurface.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Check if click is on the Gaussian surface
                if (Math.abs(distance - gaussianSurface.radius) < 10) {
                    setDraggingSurface(true);
                }
            };
            
            const handleMouseMove = (e) => {
                if (!draggingSurface || !gaussRef.current) return;
                
                const rect = gaussRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Keep Gaussian surface within bounds
                const boundedX = Math.max(gaussianSurface.radius, Math.min(rect.width - gaussianSurface.radius, x));
                const boundedY = Math.max(gaussianSurface.radius, Math.min(rect.height - gaussianSurface.radius, y));
                
                setGaussianSurface(prev => ({ ...prev, x: boundedX, y: boundedY }));
            };
            
            const handleMouseUp = () => {
                if (draggingSurface && !hasInteracted) {
                    setHasInteracted(true);
                    setShowSuccess(true);
                    onComplete();
                }
                setDraggingSurface(false);
            };
            
            const resetChallenge = () => {
                setCharges([
                    { id: 1, x: 150, y: 150, value: 5 },
                    { id: 2, x: 350, y: 250, value: -3 },
                    { id: 3, x: 250, y: 350, value: 2 }
                ]);
                setGaussianSurface({ x: 250, y: 250, radius: 100 });
                setShowSuccess(false);
                setHasInteracted(false);
            };
            
            return (
                <div className="puzzle-container">
                    <h3 className="puzzle-title">{translation.gaussChallenge.title}</h3>
                    <p style={{ textAlign: 'center', marginBottom: '20px' }}>
                        {translation.gaussChallenge.instruction}
                    </p>
                    
                    <div className="gauss-container">
                        <div 
                            ref={gaussRef}
                            className="gauss-visualization"
                            onMouseDown={handleMouseDown}
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                        >
                            {/* Charges */}
                            {charges.map(charge => (
                                <div
                                    key={charge.id}
                                    className={`gauss-charge ${charge.value > 0 ? 'positive' : 'negative'}`}
                                    style={{
                                        left: charge.x - 25,
                                        top: charge.y - 25
                                    }}
                                >
                                    {charge.value > 0 ? '+' : '-'}{Math.abs(charge.value)}
                                </div>
                            ))}
                            
                            {/* Gaussian surface */}
                            <div
                                className={`gaussian-surface ${draggingSurface ? 'dragging' : ''}`}
                                style={{
                                    left: gaussianSurface.x - gaussianSurface.radius,
                                    top: gaussianSurface.y - gaussianSurface.radius,
                                    width: gaussianSurface.radius * 2,
                                    height: gaussianSurface.radius * 2,
                                    borderColor: enclosedCharge > 0 ? '#ff6b6b' : enclosedCharge < 0 ? '#4ecdc4' : '#667eea',
                                    backgroundColor: enclosedCharge > 0 
                                        ? 'rgba(255, 107, 107, 0.1)' 
                                        : enclosedCharge < 0 
                                            ? 'rgba(78, 205, 196, 0.1)'
                                            : 'rgba(102, 126, 234, 0.1)'
                                }}
                            />
                            
                            {/* Flux indicator */}
                            <div className="flux-indicator">
                                <div className="flux-label">{translation.gaussChallenge.flux}</div>
                                <div className="flux-value">{(flux / 1e11).toFixed(2)} ×10¹¹ N·m²/C</div>
                                <div className="flux-label">{translation.gaussChallenge.enclosed}</div>
                                <div className="enclosed-value">{enclosedCharge.toFixed(2)} μC</div>
                            </div>
                        </div>
                    </div>
                    
                    {showSuccess && (
                        <div className="success-message">
                            {translation.gaussChallenge.success}
                        </div>
                    )}
                    
                    <div className="controls-container">
                        <button className="control-btn" onClick={resetChallenge}>
                            {translation.gaussChallenge.reset}
                        </button>
                    </div>
                </div>
            );
        };

        const PhysicsAdventureGame = () => {
            const [language, setLanguage] = useState('eng');
            const [currentLevel, setCurrentLevel] = useState(0); // Start with Field Visualizer
            const [gameStatus, setGameStatus] = useState('playing');
            const [completedLevels, setCompletedLevels] = useState([]);
            
            const translation = translations[language];
            const levels = translation.levels;
            
            const handleLevelComplete = () => {
                // Mark the current level as completed
                if (!completedLevels.includes(currentLevel)) {
                    setCompletedLevels(prev => [...prev, currentLevel]);
                }
            };
            
            const goToNextLevel = () => {
                if (currentLevel < levels.length - 1) {
                    setCurrentLevel(prevLevel => prevLevel + 1);
                }
            };
            
            const handlePlay = () => {
                setGameStatus('playing');
            };
            
            const handlePause = () => {
                setGameStatus('paused');
            };
            
            const handleReplay = () => {
                setCurrentLevel(0);
                setCompletedLevels([]);
                setGameStatus('playing');
            };
            
            const changeLanguage = (lang) => {
                setLanguage(lang);
                setCurrentLevel(0);
                setCompletedLevels([]);
            };
            
            const renderCurrentLevel = () => {
                switch (currentLevel) {
                    case 0:
                        return <FieldVisualizer translation={translation} onComplete={handleLevelComplete} />;
                    case 1:
                        return <CoulombsLab translation={translation} onComplete={handleLevelComplete} />;
                    case 2:
                        return <GaussChallenge translation={translation} onComplete={handleLevelComplete} />;
                    case 3:
                        return <PotentialMaze translation={translation} onComplete={handleLevelComplete} />;
                    default:
                        return <FieldVisualizer translation={translation} onComplete={handleLevelComplete} />;
                }
            };
            
            return (
                <div className="game-container">
                    <div className="game-header">
                        <h1 className="game-title">{translation.title}</h1>
                        <p className="game-subtitle">{translation.subtitle}</p>
                        <div className="language-selector">
                            <span className="globe-icon">🌐</span>
                            <select 
                                value={language} 
                                onChange={(e) => changeLanguage(e.target.value)}
                                className="language-select"
                            >
                                {Object.keys(translations).map(lang => (
                                    <option key={lang} value={lang}>{lang.toUpperCase()}</option>
                                ))}
                            </select>
                        </div>
                    </div>
                    
                    <div className="game-content">
                        <div className="level-selector">
                            {levels.map((level, index) => (
                                <div
                                    key={index}
                                    className={`level-card ${currentLevel === index ? 'active' : ''} ${completedLevels.includes(index) ? 'completed' : ''}`}
                                    onClick={() => setCurrentLevel(index)}
                                >
                                    <div className="level-icon">{level.icon}</div>
                                    <div className="level-name">{level.name}</div>
                                    <div className="level-desc">{level.desc}</div>
                                </div>
                            ))}
                        </div>
                        
                        {renderCurrentLevel()}
                        
                        <div className="controls-container">
                            {gameStatus === 'paused' ? (
                                <button className="control-btn" onClick={handlePlay}>
                                    {translation.controls.play}
                                </button>
                            ) : (
                                <button className="control-btn" onClick={handlePause}>
                                    {translation.controls.pause}
                                </button>
                            )}
                            
                            <button className="control-btn" onClick={handleReplay}>
                                {translation.controls.replay}
                            </button>
                            
                            {completedLevels.includes(currentLevel) && currentLevel < levels.length - 1 && (
                                <button className="control-btn next-btn" onClick={goToNextLevel}>
                                    {translation.controls.next}
                                </button>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<PhysicsAdventureGame />, document.getElementById('root'));
    </script>
</body>
</html>